var documenterSearchIndex = {"docs":
[{"location":"guide/#Guide","page":"Guide","title":"Guide","text":"This guide walks through the core workflow: importing a surface, generating volume points, optimizing the distribution, and preparing the point cloud for a meshless solver.","category":"section"},{"location":"guide/#Importing-a-Surface","page":"Guide","title":"Importing a Surface","text":"Load a surface mesh (STL, OBJ, or any format supported by GeoIO.jl) as a PointBoundary:\n\nusing WhatsThePoint\n\nboundary = PointBoundary(\"model.stl\")\n\nnote: Face centers, not vertices\nWhen importing a mesh, WhatsThePoint uses face centers as boundary points rather than mesh vertices. Each face becomes a SurfaceElement storing its center point, outward normal, and area. This gives a more uniform boundary representation than raw vertices.","category":"section"},{"location":"guide/#Inspecting-the-Boundary","page":"Guide","title":"Inspecting the Boundary","text":"# Number of boundary points\nlength(boundary)\n\n# Access named surfaces\nnames(boundary)              # surface names\nsurf = surfaces(boundary)[1] # first surface\n\n# Surface element data\npoints(surf)   # point coordinates\nnormal(surf)   # normal vectors\narea(surf)     # element areas","category":"section"},{"location":"guide/#Surface-Operations","page":"Guide","title":"Surface Operations","text":"Identify distinct geometric faces (walls, inlets, outlets) so you can apply different boundary conditions to each. Split surfaces at normal angle discontinuities:\n\nsplit_surface!(boundary, 75Â°)\n\nThis builds a k-nearest neighbor graph on the surface, removes edges where adjacent normals differ by more than the threshold angle, and labels each connected component as a separate named surface. See the Boundary & Normals page for details on normals, splitting, shadow points, and more.\n\nCombine multiple surfaces back into one:\n\ncombine_surfaces!(boundary, \"surface_1\", \"surface_2\")","category":"section"},{"location":"guide/#Shadow-Points-(Optional)","page":"Guide","title":"Shadow Points (Optional)","text":"Virtual points offset inward from the boundary, used in Hermite-type boundary condition enforcement (e.g., Hermite RBF-FD). Shadow points sit just inside the domain along the inward normal direction.\n\nshadow = ShadowPoints(0.5mm)\nshadow_pts = generate_shadows(surf, shadow)\n\nSee the Boundary & Normals page for more shadow point options including variable offsets.","category":"section"},{"location":"guide/#Generating-Volume-Points","page":"Guide","title":"Generating Volume Points","text":"Generate volume points from a boundary using discretize. The algorithm choice depends on the problem dimension.","category":"section"},{"location":"guide/#3D-Algorithms","page":"Guide","title":"3D Algorithms","text":"spacing = ConstantSpacing(1mm)\n\n# SlakKosec (default for 3D) â€” sphere-based candidate generation\ncloud = discretize(boundary, spacing; alg=SlakKosec())\n\n# VanDerSandeFornberg â€” grid projection with sphere packing\ncloud = discretize(boundary, spacing; alg=VanDerSandeFornberg(), max_points=100_000)\n\n# OctreeRandom â€” octree-guided random generation (no spacing needed)\ncloud = discretize(boundary, OctreeRandom(\"model.stl\"; h_min=0.5))\n\nSlakKosec can also accept a TriangleOctree for accelerated point-in-volume queries:\n\noctree = TriangleOctree(\"model.stl\"; h_min=0.5)\ncloud = discretize(boundary, spacing; alg=SlakKosec(octree))","category":"section"},{"location":"guide/#2D-Algorithm","page":"Guide","title":"2D Algorithm","text":"# FornbergFlyer (default and only option for 2D)\ncloud = discretize(boundary, spacing; alg=FornbergFlyer())","category":"section"},{"location":"guide/#Spacing-Types","page":"Guide","title":"Spacing Types","text":"Control point density with different spacing strategies:\n\n# Uniform spacing everywhere\nspacing = ConstantSpacing(1mm)\n\nAfter an initial discretization, you can use variable spacing for a second pass:\n\n# Variable spacing â€” denser near boundary, coarser in interior\n# Requires an existing PointCloud (uses boundary distances internally)\nspacing = LogLike(cloud, 0.5mm, 1.2)  # base_size, growth_rate\ncloud = discretize(boundary, spacing; alg=SlakKosec())\n\nSee the Discretization page for detailed descriptions of each algorithm and spacing type.","category":"section"},{"location":"guide/#Node-Repulsion","page":"Guide","title":"Node Repulsion","text":"Discretization gives approximate uniformity; repulsion refines it to minimize interpolation error in the meshless solver.\n\ncloud, convergence = repel(cloud, spacing; Î²=0.2, max_iters=1000)\n\nrepel returns a tuple of (new_cloud, convergence_vector). The new cloud has NoTopology since points have moved.\n\nnote: Only volume points are repelled\nBoundary points remain fixed â€” only volume (interior) points are moved during repulsion. This preserves the original boundary geometry.\n\ntip: Tuning repulsion\nThe default parameters (Î²=0.2, k=21, max_iters=1000) work well for most problems. Check convergence[end] to verify the distribution has stabilized. See the Node Repulsion page for detailed parameter guidance.","category":"section"},{"location":"guide/#Verifying-Distribution-Quality","page":"Guide","title":"Verifying Distribution Quality","text":"Use metrics to inspect the point distribution before and after repulsion:\n\nmetrics(cloud)  # prints distance statistics to k nearest neighbors\n\nThis prints the average, standard deviation, maximum, and minimum distances to each point's k nearest neighbors â€” useful for quantifying how uniform the distribution is.","category":"section"},{"location":"guide/#Topology-(Point-Connectivity)","page":"Guide","title":"Topology (Point Connectivity)","text":"Meshless solvers compute derivatives using local neighborhoods. Topology pre-computes these neighborhoods so they are ready when the solver needs them.\n\n# k-nearest neighbors\ncloud = set_topology(cloud, KNNTopology, 21)\n\n# Or radius-based neighbors\ncloud = set_topology(cloud, RadiusTopology, 2mm)\n\n# Access neighbor indices\nneighbors(cloud, 5)   # neighbors of point 5\nneighbors(cloud)       # all neighborhoods\n\n# Check state\nhastopology(cloud)     # true\n\nTopology can also be set on individual surfaces and volumes:\n\nsurf = set_topology(surf, KNNTopology, 10)\nneighbors(surf, i)  # local indices within the surface\n\nnote: Local vs global indices\nTopology on a PointSurface or PointVolume uses local indices (1 through length(surf)). Topology on a PointCloud uses global indices (1 through length(cloud)) where boundary points come first, followed by volume points. See Concepts for details.","category":"section"},{"location":"guide/#Visualization","page":"Guide","title":"Visualization","text":"Visualize point clouds and boundaries using Makie.jl:\n\nusing GLMakie\n\nvisualize(cloud; markersize=0.15)\nvisualize(boundary; markersize=0.15)","category":"section"},{"location":"guide/#Export","page":"Guide","title":"Export","text":"Save a point cloud to VTK format for use in external tools:\n\nexport_cloud(\"output.vtk\", cloud)","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"The fundamental data structures for representing point clouds.","category":"section"},{"location":"api/#Accessors","page":"API Reference","title":"Accessors","text":"Common accessor functions for point cloud types.","category":"section"},{"location":"api/#Topology","page":"API Reference","title":"Topology","text":"Point connectivity for meshless stencils.","category":"section"},{"location":"api/#Discretization","page":"API Reference","title":"Discretization","text":"Volume point generation algorithms and spacing types.","category":"section"},{"location":"api/#Boundary-Operations","page":"API Reference","title":"Boundary Operations","text":"Normal computation and surface manipulation.","category":"section"},{"location":"api/#Shadow-Points","page":"API Reference","title":"Shadow Points","text":"Virtual points offset inward from the boundary for Hermite-type boundary condition enforcement.","category":"section"},{"location":"api/#Geometry-and-Queries","page":"API Reference","title":"Geometry and Queries","text":"Point-in-volume testing, octree acceleration, and spatial utilities.","category":"section"},{"location":"api/#Node-Repulsion","page":"API Reference","title":"Node Repulsion","text":"Point distribution optimization.","category":"section"},{"location":"api/#Diagnostics","page":"API Reference","title":"Diagnostics","text":"","category":"section"},{"location":"api/#I/O","page":"API Reference","title":"I/O","text":"","category":"section"},{"location":"api/#Unexported-API","page":"API Reference","title":"Unexported API","text":"","category":"section"},{"location":"api/#WhatsThePoint.AbstractSurface","page":"API Reference","title":"WhatsThePoint.AbstractSurface","text":"abstract type AbstractSurface{M<:Manifold,C<:CRS} end\n\nA surface of a PointSurface.\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.PointSurface","page":"API Reference","title":"WhatsThePoint.PointSurface","text":"struct PointSurface{M,C,S,T} <: AbstractSurface{M,C}\n\nThis is a typical representation of a surface via points.\n\nType Parameters\n\nM<:Manifold - manifold type\nC<:CRS - coordinate reference system\nS - shadow type\nT<:AbstractTopology - topology type for surface-local connectivity\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.SurfaceElement","page":"API Reference","title":"WhatsThePoint.SurfaceElement","text":"struct SurfaceElement{M,C,N,A}\n\nRepresentation of a point on a <:PointSurface.\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.PointBoundary","page":"API Reference","title":"WhatsThePoint.PointBoundary","text":"struct PointBoundary{M,C} <: Domain{M,C}\n\nA boundary of points.\n\nFields\n\nsurfaces: Named surfaces forming the boundary\n\nType Parameters\n\nM <: Manifold: The manifold type\nC <: CRS: The coordinate reference system\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.PointVolume","page":"API Reference","title":"WhatsThePoint.PointVolume","text":"struct PointVolume{M,C,T,V} <: Domain{M,C}\n\nInterior volume points with optional topology.\n\nType Parameters\n\nM<:Manifold - manifold type\nC<:CRS - coordinate reference system\nT<:AbstractTopology - topology type for volume-local connectivity\nV<:AbstractVector{Point{M,C}} - storage type (allows GPU arrays)\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.PointCloud","page":"API Reference","title":"WhatsThePoint.PointCloud","text":"struct PointCloud{M,C,T} <: Domain{M,C}\n\nA point cloud with optional topology (connectivity).\n\nType Parameters\n\nM<:Manifold - manifold type\nC<:CRS - coordinate reference system\nT<:AbstractTopology - topology type for cloud-level connectivity\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.points","page":"API Reference","title":"WhatsThePoint.points","text":"points(surf::PointSurface)\n\nReturn vector of points from surface. Alias for point(surf).\n\n\n\n\n\npoints(vol::PointVolume)\n\nReturn vector of points from volume.\n\n\n\n\n\npoints(boundary::PointBoundary)\n\nReturn vector of all points from all surfaces in the boundary.\n\n\n\n\n\npoints(cloud::PointCloud)\n\nReturn vector of all points (boundary + volume).\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.point","page":"API Reference","title":"WhatsThePoint.point","text":"point(surf::PointSurface)\n\nReturn the vector of point coordinates for all surface elements.\n\n\n\n\n\n","category":"function"},{"location":"api/#Meshes.normal","page":"API Reference","title":"Meshes.normal","text":"normal(surf::PointSurface)\n\nReturn the vector of outward unit normal vectors for all surface elements.\n\n\n\n\n\n","category":"function"},{"location":"api/#Meshes.area","page":"API Reference","title":"Meshes.area","text":"area(surf::PointSurface)\n\nReturn the vector of surface areas for all surface elements.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.topology","page":"API Reference","title":"WhatsThePoint.topology","text":"topology(surf::PointSurface)\n\nReturn the topology of the surface.\n\n\n\n\n\ntopology(vol::PointVolume)\n\nReturn the topology of the volume.\n\n\n\n\n\ntopology(cloud::PointCloud)\n\nReturn the topology of the point cloud.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.AbstractTopology","page":"API Reference","title":"WhatsThePoint.AbstractTopology","text":"abstract type AbstractTopology{S}\n\nAbstract base type for point cloud topology (connectivity). Type parameter S is the storage format for neighbor indices.\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.NoTopology","page":"API Reference","title":"WhatsThePoint.NoTopology","text":"struct NoTopology <: AbstractTopology{Nothing}\n\nSingleton type representing no topology. Default for PointCloud.\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.KNNTopology","page":"API Reference","title":"WhatsThePoint.KNNTopology","text":"mutable struct KNNTopology{S} <: AbstractTopology{S}\n\nk-nearest neighbors topology.\n\nFields\n\nneighbors::S - neighbor indices storage\nk::Int - number of neighbors per point\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.RadiusTopology","page":"API Reference","title":"WhatsThePoint.RadiusTopology","text":"mutable struct RadiusTopology{S,R} <: AbstractTopology{S}\n\nRadius-based topology where neighbors are all points within a given radius.\n\nFields\n\nneighbors::S - neighbor indices storage\nradius::R - search radius (scalar or function of position)\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.set_topology","page":"API Reference","title":"WhatsThePoint.set_topology","text":"set_topology(surf::PointSurface, ::Type{KNNTopology}, k::Int)\n\nBuild and return new surface with k-nearest neighbor topology.\n\n\n\n\n\nset_topology(surf::PointSurface, ::Type{RadiusTopology}, radius)\n\nBuild and return new surface with radius-based topology.\n\n\n\n\n\nset_topology(vol::PointVolume, ::Type{KNNTopology}, k::Int)\n\nBuild and return new volume with k-nearest neighbor topology.\n\n\n\n\n\nset_topology(vol::PointVolume, ::Type{RadiusTopology}, radius)\n\nBuild and return new volume with radius-based topology.\n\n\n\n\n\nset_topology(cloud::PointCloud, ::Type{KNNTopology}, k::Int)\n\nBuild and return new cloud with k-nearest neighbor topology.\n\n\n\n\n\nset_topology(cloud::PointCloud, ::Type{RadiusTopology}, radius)\n\nBuild and return new cloud with radius-based topology.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.rebuild_topology!","page":"API Reference","title":"WhatsThePoint.rebuild_topology!","text":"rebuild_topology!(topo::NoTopology, points)\n\nNo-op for NoTopology (nothing to rebuild).\n\n\n\n\n\nrebuild_topology!(topo::KNNTopology, points)\n\nRebuild k-nearest neighbor topology in place.\n\n\n\n\n\nrebuild_topology!(topo::RadiusTopology, points)\n\nRebuild radius-based topology in place.\n\n\n\n\n\nrebuild_topology!(surf::PointSurface)\n\nRebuild topology in place using same parameters. No-op if NoTopology.\n\n\n\n\n\nrebuild_topology!(vol::PointVolume)\n\nRebuild topology in place using same parameters. No-op if NoTopology.\n\n\n\n\n\nrebuild_topology!(cloud::PointCloud)\n\nRebuild topology in place using same parameters. No-op if NoTopology.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.neighbors","page":"API Reference","title":"WhatsThePoint.neighbors","text":"neighbors(t::AbstractTopology)\n\nReturn the neighbor storage from a topology.\n\n\n\n\n\nneighbors(t::AbstractTopology, i::Int)\n\nReturn neighbors of point i.\n\n\n\n\n\nneighbors(surf::PointSurface)\n\nReturn all neighbor lists from the surface topology. Throws error if no topology.\n\n\n\n\n\nneighbors(surf::PointSurface, i::Int)\n\nReturn neighbors of point i in surface-local indices. Throws error if no topology.\n\n\n\n\n\nneighbors(vol::PointVolume)\n\nReturn all neighbor lists from the volume topology. Throws error if no topology.\n\n\n\n\n\nneighbors(vol::PointVolume, i::Int)\n\nReturn neighbors of point i in volume-local indices. Throws error if no topology.\n\n\n\n\n\nneighbors(cloud::PointCloud)\n\nReturn all neighbor lists from the topology. Throws error if no topology or invalid.\n\n\n\n\n\nneighbors(cloud::PointCloud, i::Int)\n\nReturn neighbors of point i. Throws error if no topology or invalid.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.hastopology","page":"API Reference","title":"WhatsThePoint.hastopology","text":"hastopology(surf::PointSurface)\n\nCheck if surface has a topology (not NoTopology).\n\n\n\n\n\nhastopology(vol::PointVolume)\n\nCheck if volume has a topology (not NoTopology).\n\n\n\n\n\nhastopology(cloud::PointCloud)\n\nCheck if point cloud has a topology (not NoTopology).\n\n\n\n\n\n","category":"function"},{"location":"api/#Meshes.discretize","page":"API Reference","title":"Meshes.discretize","text":"discretize(bnd::PointBoundary, spacing; alg=auto, max_points=10_000_000)\n\nGenerate volume points for the given boundary and return a new PointCloud.\n\nspacing can be either an AbstractSpacing object or a bare Unitful.Length value (which will be wrapped in ConstantSpacing).\n\nKeyword Arguments\n\nalg: Discretization algorithm (default: SlakKosec() for 3D)\nmax_points: Maximum number of volume points to generate\n\nExample\n\nmesh = GeoIO.load(\"model.stl\").geometry\nboundary = PointBoundary(mesh)\noctree = TriangleOctree(mesh; h_min=0.1)\ncloud = discretize(boundary, 3.0m; alg=SlakKosec(octree), max_points=100_000)\n\n\n\n\n\ndiscretize(cloud::PointCloud, spacing; alg=auto, max_points=10_000_000)\n\nGenerate volume points for an existing cloud and return a new PointCloud with the volume populated.\n\n\n\n\n\ndiscretize(bnd::PointBoundary{ð”¼{3}}, alg::OctreeRandom; max_points=10_000_000)\n\nGenerate volume points using OctreeRandom without requiring a spacing parameter.\n\nOctreeRandom generates uniformly random points and does not use spacing, so this overload removes the need for a dummy spacing value.\n\nExample\n\nmesh = GeoIO.load(\"bunny.stl\").geometry\nboundary = PointBoundary(mesh)\ncloud = discretize(boundary, OctreeRandom(mesh); max_points=100_000)\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.SlakKosec","page":"API Reference","title":"WhatsThePoint.SlakKosec","text":"SlakKosec <: AbstractNodeGenerationAlgorithm\n\nSlak-Kosec algorithm for volume point generation with optional octree acceleration.\n\nThe algorithm generates candidate points on spheres around existing points and accepts them if they are inside the domain and sufficiently far from existing points.\n\nFields\n\nn::Int - Number of candidate points per sphere (default: 10)\noctree::Union{Nothing,TriangleOctree} - Optional octree for fast isinside queries\n\nConstructors\n\nSlakKosec()                          # Default: n=10, no octree\nSlakKosec(20)                        # Custom n, no octree\nSlakKosec(octree::TriangleOctree)    # Use octree acceleration with n=10\nSlakKosec(20, octree)                # Custom n with octree acceleration\n\nPerformance\n\nWithout octree: Uses Green's function for isinside (~50ms per query)\nWith octree: Uses spatial indexing (~0.05ms per query, 1000Ã— faster!)\n\nUsage Examples\n\nStandard Usage (Green's function)\n\nusing WhatsThePoint\n\n# Load boundary\nboundary = PointBoundary(\"model.stl\")\ncloud = PointCloud(boundary)\n\n# Discretize without octree (slow for large domains)\nspacing = ConstantSpacing(1.0u\"m\")\nresult = discretize(cloud, spacing; alg=SlakKosec(), max_points=10_000)\n\nOctree-Accelerated Usage (Recommended for large domains)\n\nusing WhatsThePoint\n\n# Load boundary points\nboundary = PointBoundary(\"model.stl\")\ncloud = PointCloud(boundary)\n\n# Build octree from STL file (Option 1: simplest)\noctree = TriangleOctree(\"model.stl\"; h_min=0.01, classify_leaves=true)\n\n# Or from SimpleMesh (Option 2)\n# mesh = GeoIO.load(\"model.stl\").geometry\n# octree = TriangleOctree(mesh; h_min=0.01, classify_leaves=true)\n\n# Use octree-accelerated discretization (100-1000Ã— faster!)\nspacing = ConstantSpacing(1.0u\"m\")\nalg = SlakKosec(octree)  # Pass octree to algorithm\nresult = discretize(cloud, spacing; alg=alg, max_points=100_000)\n\nReferences\n\nÅ lak J, Kosec G. \"On generation of node distributions for meshless PDE discretizations\" (2019)\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.VanDerSandeFornberg","page":"API Reference","title":"WhatsThePoint.VanDerSandeFornberg","text":"VanDerSandeFornberg <: AbstractNodeGenerationAlgorithm\n\n3D volume discretization algorithm that projects a 2D grid onto the shadow plane and fills the volume layer by layer using sphere packing heights. Requires ConstantSpacing.\n\nSee: Van der Sande, K. & Fornberg, B. (2021). SIAM J. Sci. Comput., 43(1).\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.FornbergFlyer","page":"API Reference","title":"WhatsThePoint.FornbergFlyer","text":"FornbergFlyer <: AbstractNodeGenerationAlgorithm\n\n2D volume discretization algorithm using a height-field approach projected onto the x-axis. This is the default and only algorithm for 2D boundaries. Requires ConstantSpacing.\n\nSee: Fornberg, B. & Flyer, N. (2015). Comput. Math. Appl., 69(7).\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.OctreeRandom","page":"API Reference","title":"WhatsThePoint.OctreeRandom","text":"OctreeRandom <: AbstractNodeGenerationAlgorithm\n\nOctree-guided random point generation for volume discretization.\n\nThis algorithm uses a TriangleOctree with leaf classification to efficiently generate random points inside the mesh. It's much faster than rejection sampling because:\n\nOnly samples in interior/boundary regions (skips exterior entirely)\nInterior boxes need no filtering (100% acceptance rate)\nOnly boundary boxes require isinside() checks\n\nFields\n\noctree::TriangleOctree - Octree with leaf classification\nboundary_oversampling::Float64 - Oversampling factor for boundary boxes (default: 2.0)\nverify_interior::Bool - Per-point signed distance verification for interior leaves (default: false)\n\nConstructors\n\n# From mesh (recommended) â€” builds octree automatically with classified leaves\nOctreeRandom(mesh::SimpleMesh)                          # Auto h_min\nOctreeRandom(mesh; h_min=0.01, boundary_oversampling=2.0)  # Custom h_min\n\n# From file path â€” loads mesh then builds octree\nOctreeRandom(\"bunny.stl\")\nOctreeRandom(\"bunny.stl\"; h_min=0.01)\n\n# From pre-built octree (advanced)\nOctreeRandom(octree::TriangleOctree)\nOctreeRandom(octree, oversampling; verify_interior=false)\n\nPerformance\n\nInterior leaves: O(1) per point (no filtering needed)\nBoundary leaves: O(k) per point where k â‰ˆ 10-50 triangles\nMuch faster than bounding box rejection: Typical acceptance 5-20% vs 90%+ here\n\nUsage Examples\n\nRecommended Usage\n\nusing WhatsThePoint\n\nmesh = GeoIO.load(\"bunny.stl\").geometry\nboundary = PointBoundary(mesh)\ncloud = discretize(boundary, OctreeRandom(mesh); max_points=100_000)\n\nWith Spacing (backward compatible)\n\noctree = TriangleOctree(mesh; h_min=0.01, classify_leaves=true)\ncloud = discretize(boundary, 1.0u\"m\"; alg=OctreeRandom(octree), max_points=10_000)\n\nWith Custom Oversampling\n\nalg = OctreeRandom(mesh; boundary_oversampling=2.5)\ncloud = discretize(boundary, alg; max_points=10_000)\n\nNotes\n\nThe mesh convenience constructor always sets classify_leaves=true\nWhen h_min is omitted, it is computed as bbox_diagonal / (2 * cbrt(n_triangles))\nThe spacing parameter is not used (random uniform distribution)\nFor spacing-based discretization, use SlakKosec or VanDerSandeFornberg\nActual point count may be slightly less than max_points due to boundary filtering\nOversampling 1.5-3.0 is recommended; higher values waste computation\n\nAlgorithm Details\n\nIdentify regions: Separate octree leaves into interior (2) and boundary (1)\nAllocate points: Distribute target count proportionally to leaf volumes\nGenerate interior points: Random sampling in interior boxes (no filtering)\nGenerate boundary points: Oversample and filter with isinside()\nReturn: Combined set of validated interior points\n\nWhen to Use\n\nGood for:\n\nQuick initial discretization\nUniform random distributions\nMaximum point count targets\nTesting and prototyping\n\nNot ideal for:\n\nSpacing-controlled discretization (use SlakKosec instead)\nAdaptive refinement\nSmooth point distributions\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.ConstantSpacing","page":"API Reference","title":"WhatsThePoint.ConstantSpacing","text":"ConstantSpacing{L<:Unitful.Length} <: AbstractSpacing\n\nConstant node spacing.\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.LogLike","page":"API Reference","title":"WhatsThePoint.LogLike","text":"LogLike <: VariableSpacing\n\nNode spacing based on a log-like function of the distance to nearest boundary x(x+a)     where x is the distance to the nearest boundary and a is a parameter to control     the growth rate as a = 1 - (g - 1) where g is the conventional growth rate     parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.Power","page":"API Reference","title":"WhatsThePoint.Power","text":"Power <: VariableSpacing\n\nNode spacing based on a power of the distance to nearest boundary x^g where x is     the distance to the nearest boundary and g is the growth_rate.\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.compute_normals","page":"API Reference","title":"WhatsThePoint.compute_normals","text":"compute_normals(surf::PointSurface{ð”¼{N},C}; k::Int=5) where {N,C<:CRS}\n\nEstimate the normals of a set of points that form a surface. Uses the PCA approach from \"Surface Reconstruction from Unorganized Points\" - Hoppe (1992).\n\nRequires Euclidean manifold (ð”¼{2} or ð”¼{3}). This function assumes flat space geometry.\n\n\n\n\n\ncompute_normals(search_method::KNearestSearch, surf::PointSurface{ð”¼{N},C}) where {N,C<:CRS}\n\nEstimate the normals of a set of points that form a surface. Uses the PCA approach from \"Surface Reconstruction from Unorganized Points\" - Hoppe (1992).\n\nRequires Euclidean manifold (ð”¼{2} or ð”¼{3}). This function assumes flat space geometry.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.orient_normals!","page":"API Reference","title":"WhatsThePoint.orient_normals!","text":"orient_normals!(search_method::KNearestSearch, normals::AbstractVector{<:AbstractVector}, points)\n\nCorrect the orientation of normals on a surface as the compute_normals function does not guarantee if the normal is inward or outward facing. Uses the approach from \"Surface Reconstruction from Unorganized Points\" - Hoppe (1992).\n\n\n\n\n\norient_normals!(normals::AbstractVector{<:AbstractVector}, points::AbstractVector{<:Point{ð”¼{N}}}; k::Int=5) where {N}\n\nCorrect the orientation of normals on a surface as the compute_normals function does not guarantee if the normal is inward or outward facing. Uses the approach from \"Surface Reconstruction from Unorganized Points\" - Hoppe (1992).\n\nRequires Euclidean manifold (ð”¼{2} or ð”¼{3}). This function uses Euclidean dot products for orientation consistency.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.update_normals!","page":"API Reference","title":"WhatsThePoint.update_normals!","text":"update_normals!(surf::PointSurface{ð”¼{N},C}; k::Int=5) where {N,C<:CRS}\n\nUpdate the normals of the boundary of a surf. This is necessary whenever the points change for any reason.\n\nRequires Euclidean manifold (ð”¼{2} or ð”¼{3}). This function assumes flat space geometry.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.split_surface!","page":"API Reference","title":"WhatsThePoint.split_surface!","text":"split_surface!(cloud, angle; k=10)\nsplit_surface!(cloud, target_surf, angle; k=10)\n\nSplit a surface into sub-surfaces based on normal angle discontinuities. Builds a k-nearest neighbor graph, removes edges where adjacent normals differ by more than angle, and labels each connected component as a separate named surface.\n\nWhen called on a cloud/boundary with a single surface, that surface is split automatically. When multiple surfaces exist, specify target_surf by name.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.combine_surfaces!","page":"API Reference","title":"WhatsThePoint.combine_surfaces!","text":"combine_surfaces!(boundary::PointBoundary, surfs...)\n\nMerge multiple named surfaces into one. The first name is kept and subsequent surfaces are merged into it. All original surfaces are removed and replaced by the combined surface.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.ShadowPoints","page":"API Reference","title":"WhatsThePoint.ShadowPoints","text":"ShadowPoints(Î”, order=1)\nShadowPoints(Î”::Number, order)\n\nShadow point configuration for generating virtual points offset inward from the boundary. Î” is the offset distance (constant or a function of position). order is the derivative order for Hermite-type boundary condition enforcement.\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.generate_shadows","page":"API Reference","title":"WhatsThePoint.generate_shadows","text":"generate_shadows(points, normals, shadow::ShadowPoints)\ngenerate_shadows(surf::PointSurface, shadow::ShadowPoints)\ngenerate_shadows(cloud::PointCloud, shadow::ShadowPoints)\n\nGenerate shadow points offset inward from the boundary along the normal direction by the distance specified in shadow. Returns a vector of Point objects.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.isinside","page":"API Reference","title":"WhatsThePoint.isinside","text":"isinside(point::SVector{3,T}, octree::TriangleOctree) -> Bool\n\nFast interior/exterior test using octree spatial index.\n\nReturns true if point is inside the closed surface defined by the mesh.\n\nPerformance\n\nComplexity: O(log M + k) where M = number of triangles, k â‰ˆ 10-50\nSpeedup: 100-1000Ã— faster than brute-force O(M) approach\n\nExample\n\nusing WhatsThePoint, StaticArrays\n\noctree = TriangleOctree(\"model.stl\"; h_min=0.01, classify_leaves=true)\n\npoint = SVector(0.5, 0.5, 0.5)\nis_inside = isinside(point, octree)\n\n\n\n\n\nisinside(points::Vector{SVector{3,T}}, octree::TriangleOctree) -> Vector{Bool}\n\nBatch interior test for multiple points.\n\nExample\n\ntest_points = [SVector(randn(3)...) for _ in 1:1000]\nresults = isinside(test_points, octree)  # Returns Vector{Bool}\n\n\n\n\n\nisinside(point::Point{ð”¼{3}}, octree::TriangleOctree{ð”¼{3},C,T}) -> Bool\n\nBridge from Meshes.jl Point to SVector-based isinside.\n\nExtracts coordinates from Point, converts to SVector{3,T}, and delegates to the SVector method.\n\n\n\n\n\nisinside(points::AbstractVector{<:Point{ð”¼{3}}}, octree::TriangleOctree{ð”¼{3}}) -> Vector{Bool}\n\nBatch bridge from Meshes.jl Points to SVector-based isinside.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.TriangleOctree","page":"API Reference","title":"WhatsThePoint.TriangleOctree","text":"TriangleOctree{M<:Manifold, C<:CRS, T<:Real}\n\nAn octree-based spatial index for efficient triangle mesh queries.\n\nFields\n\ntree::SpatialOctree{Int,T}: Underlying octree storing triangle indices\nmesh::SimpleMesh{M,C}: Original Meshes.jl mesh (single source of truth for triangle data)\nleaf_classification::Union{Nothing, Vector{Int8}}: Classification of empty leaves\n0: Exterior (outside mesh)\n1: Boundary (near surface but empty)\n2: Interior (inside mesh)\n\nPerformance\n\nFor a mesh with M triangles:\n\nConstruction: O(M log M) - distribute triangles to boxes\nQuery: O(log M + k) where k â‰ˆ 10-50 triangles per leaf\nMemory: O(N) for octree nodes (mesh data accessed on-the-fly)\n\nExample\n\n# Option 1: From STL file (simplest)\noctree = TriangleOctree(\"model.stl\"; h_min=0.01, classify_leaves=true)\n\n# Option 2: From SimpleMesh\nmesh = GeoIO.load(\"model.stl\").geometry\noctree = TriangleOctree(mesh; h_min=0.01, classify_leaves=true)\n\n# Fast queries (100-1000x speedup over brute force)\npoint = SVector(0.5, 0.5, 0.5)\nis_inside = isinside(point, octree)\n\nWorkflow with PointBoundary\n\nSince PointBoundary discards mesh topology, build both from the same mesh:\n\nmesh = GeoIO.load(\"model.stl\").geometry\nboundary = PointBoundary(mesh)\noctree = TriangleOctree(mesh; h_min=0.01, classify_leaves=true)\ncloud = discretize(boundary, spacing; alg=OctreeRandom(octree))\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.has_consistent_normals","page":"API Reference","title":"WhatsThePoint.has_consistent_normals","text":"has_consistent_normals(mesh::SimpleMesh) -> Bool\n\nCheck if triangle faces are consistently oriented (manifold orientation test).\n\nThis function verifies that all shared edges between adjacent triangles are traversed in OPPOSITE directions, which is the geometric requirement for a properly oriented manifold surface. This test is independent of surface curvature.\n\nAlgorithm\n\nFor each shared edge between two triangles:\n\nTriangle A has edge v1â†’v2\nTriangle B (adjacent) must have edge v2â†’v1 (opposite direction)\nIf both traverse in the same direction â†’ faces are incorrectly oriented\n\nReturns\n\ntrue if all triangles are correctly oriented (manifold surface)\nfalse if any triangles have flipped faces (orientation errors)\n\nPerformance\n\nO(n) complexity using edge hash map instead of O(nÂ²) pairwise comparison.\n\nExamples\n\noctree = TriangleOctree(\"model.stl\"; h_min=0.01)\nif !has_consistent_normals(octree.mesh)\n    @warn \"Mesh has flipped triangles - will cause incorrect isinside() results\"\nend\n\nNote\n\nThis test uses GEOMETRIC edge orientation, not algebraic normal dot products. It will correctly validate meshes with high curvature (sharp edges, creases).\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.emptyspace","page":"API Reference","title":"WhatsThePoint.emptyspace","text":"emptyspace(testpoint, points)\n\nCheck if a point occupies empty space within a certain tolerance.\n\n\n\n\n\n","category":"function"},{"location":"api/#Meshes.boundingbox","page":"API Reference","title":"Meshes.boundingbox","text":"boundingbox(pts::AbstractVector{<:Point})\n\nCompute the axis-aligned bounding box of a collection of points.\n\n\n\n\n\n","category":"function"},{"location":"api/#Meshes.centroid","page":"API Reference","title":"Meshes.centroid","text":"centroid(pts::AbstractVector{<:Point})\n\nCompute the centroid (geometric center) of a collection of points.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.repel","page":"API Reference","title":"WhatsThePoint.repel","text":"repel(cloud::PointCloud, spacing; Î²=0.2, Î±=auto, k=21, max_iters=1000, tol=1e-6)\n\nOptimize point distribution via node repulsion (Miotti 2023). Returns (new_cloud, convergence_vector) tuple.\n\nThe returned cloud has NoTopology since points have moved.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.metrics","page":"API Reference","title":"WhatsThePoint.metrics","text":"metrics(cloud::PointCloud; k=20)\n\nPrint distance statistics (mean, std, max, min) to the k nearest neighbors for all points in the cloud. Useful for assessing point distribution quality before and after repulsion.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.import_surface","page":"API Reference","title":"WhatsThePoint.import_surface","text":"import_surface(filepath::String)\n\nLoad a surface mesh from a file (STL, OBJ, or any format supported by GeoIO.jl). Returns a tuple of (points, normals, areas, mesh) where points are face centers.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.export_cloud","page":"API Reference","title":"WhatsThePoint.export_cloud","text":"export_cloud(filename::String, cloud::PointCloud)\n\nExport a point cloud to VTK format. The output file contains boundary point coordinates and normal vectors.\n\n\n\n\n\n","category":"function"},{"location":"api/#FileIO.save","page":"API Reference","title":"FileIO.save","text":"save(filename::String, cloud::PointCloud)\n\nSave a point cloud to a file using FileIO.jl serialization.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.AbstractOctree","page":"API Reference","title":"WhatsThePoint.AbstractOctree","text":"AbstractOctree{E,T} = AbstractSpatialTree{3,E,T}\n\nConvenience alias for 3D spatial trees (octrees).\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.AbstractSpatialTree","page":"API Reference","title":"WhatsThePoint.AbstractSpatialTree","text":"AbstractSpatialTree{N,E,T}\n\nAbstract type for N-dimensional spatial trees.\n\nType Parameters\n\nN::Int: Spatial dimensionality (2 for quadtree, 3 for octree)\nE: Element type stored in tree (e.g., Int for indices)\nT<:Real: Coordinate numeric type (Float64, Float32, etc.)\n\nInterface Requirements\n\nTrees must implement:\n\nfind_leaf(tree, point) - Locate leaf containing point\nbounding_box(tree) - Get overall bounds\nnum_elements(tree) - Total elements stored\n\nOptional:\n\nfind_neighbors(tree, box_idx, direction) - Neighbor queries\nbalance!(tree) - Enforce refinement constraints\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.AndCriterion","page":"API Reference","title":"WhatsThePoint.AndCriterion","text":"AndCriterion{T<:Tuple} <: SubdivisionCriterion\n\nCombine multiple criteria - all must be satisfied for subdivision.\n\nFields\n\ncriteria::T: Tuple of criteria to combine (parametrized for type stability)\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.MaxElementsCriterion","page":"API Reference","title":"WhatsThePoint.MaxElementsCriterion","text":"MaxElementsCriterion <: SubdivisionCriterion\n\nSubdivide box if number of elements exceeds threshold.\n\nFields\n\nmax_elements::Int: Maximum elements before subdivision\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.NearestTriangleState","page":"API Reference","title":"WhatsThePoint.NearestTriangleState","text":"NearestTriangleState{T<:Real}\n\nMutable state for nearest-triangle search, replacing 3 separate Ref allocations with a single struct (1 heap allocation instead of 3, enables potential SROA).\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.SizeCriterion","page":"API Reference","title":"WhatsThePoint.SizeCriterion","text":"SizeCriterion{T<:Real} <: SubdivisionCriterion\n\nSubdivide box if size exceeds threshold.\n\nFields\n\nh_min::T: Minimum box size (stop subdividing when reached)\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.SpatialOctree","page":"API Reference","title":"WhatsThePoint.SpatialOctree","text":"SpatialOctree{E,T<:Real} <: AbstractOctree{E,T}\n\nConcrete octree implementation using integer coordinate system for efficient neighbor finding.\n\nUses (i,j,k,N) coordinate system where:\n\n(i,j,k) are integer coordinates at refinement level N\nBox center = origin + (2*[i,j,k] + 1) * (root_size / N) / 2\nEnables O(1) neighbor calculation from coordinates\n\nType Parameters\n\nE: Type of elements stored (e.g., Int for triangle IDs)\nT: Coordinate numeric type (e.g., Float64, Float32)\n\nFields\n\nparent::Vector{Int}: Parent box index for each node (0 = root has no parent)\nchildren::Vector{SVector{8,Int}}: 8 child indices per box (0 = no child)\ncoords::Vector{SVector{4,Int}}: (i,j,k,N) coordinates per box where N is refinement level\norigin::SVector{3,T}: Spatial origin of root box\nroot_size::T: Size of root box (assumed cubic)\nelement_lists::Vector{Vector{E}}: Elements in each box\nnum_boxes::Ref{Int}: Current number of boxes (mutable counter)\n\nInterface Implementation\n\nImplements AbstractSpatialTree interface:\n\nfind_leaf(tree, point) - O(log n) point location\nbounding_box(tree) - Root box bounds\nnum_elements(tree) - Total stored elements\nfind_neighbor(tree, box, dir) - 6-directional neighbor finding\nbalance_octree!(tree) - 2:1 refinement constraint\n\nExample\n\nusing StaticArrays\n\norigin = SVector(0.0, 0.0, 0.0)\noctree = SpatialOctree{Int,Float64}(origin, 10.0)\n\n# Subdivide root\nsubdivide!(octree, 1)\n\n# Find leaf containing point\npoint = SVector(2.0, 2.0, 2.0)\nleaf = find_leaf(octree, point)\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.SpatialOctree-Union{Tuple{T}, Tuple{E}, Tuple{StaticArraysCore.SVector{3, T}, T}} where {E, T}","page":"API Reference","title":"WhatsThePoint.SpatialOctree","text":"SpatialOctree{E,T}(origin::SVector{3,T}, size::T; initial_capacity=1000)\n\nCreate empty octree with root node.\n\nArguments\n\norigin: Minimum corner of root box\nsize: Edge length of root box (assumed cubic)\ninitial_capacity: Initial array capacity (will grow as needed)\n\nExample\n\norigin = SVector(0.0, 0.0, 0.0)\noctree = SpatialOctree{Int,Float64}(origin, 10.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.SubdivisionCriterion","page":"API Reference","title":"WhatsThePoint.SubdivisionCriterion","text":"SubdivisionCriterion\n\nAbstract type for subdivision decision logic.\n\nAllows pluggable subdivision criteria via dispatch.\n\nBuilt-in Criteria\n\nMaxElementsCriterion(max_elements) - Subdivide if too many elements\nSizeCriterion(h_min) - Subdivide until box small enough\nAndCriterion(criteria...) - All criteria must be satisfied\n\nExample\n\ncriterion = AndCriterion((\n    MaxElementsCriterion(50),\n    SizeCriterion(0.1)\n))\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.filter-Tuple{Function, PointVolume}","page":"API Reference","title":"Base.filter","text":"filter(f::Function, vol::PointVolume)\n\nReturn new PointVolume with only points satisfying predicate f. Topology is stripped since point indices change.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isvalid-Tuple{Union{KNNTopology, RadiusTopology}}","page":"API Reference","title":"Base.isvalid","text":"isvalid(t::AbstractTopology)\n\nCheck if topology is valid. With immutable design, topology is always valid if it exists.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._allocate_counts_by_volume-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T<:Real","page":"API Reference","title":"WhatsThePoint._allocate_counts_by_volume","text":"_allocate_counts_by_volume(volumes, total_count; ensure_one=false)\n\nAllocate integer counts across leaves proportionally to volumes using largest-remainder rounding, preserving exact total count.\n\nIf ensure_one=true and total_count >= length(volumes), each leaf gets at least one allocation before distributing the remainder by volume.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._auto_h_min-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh}} where T","page":"API Reference","title":"WhatsThePoint._auto_h_min","text":"_auto_h_min(::Type{T}, mesh::SimpleMesh) where {T}\n\nCompute a default h_min for octree construction based on mesh geometry.\n\nHeuristic: bbox_diagonal / (2 * cbrt(n_triangles)). Scales leaf size to the mesh's characteristic triangle spacing so the octree resolves surface detail without excessive subdivision.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._build_knn_neighbors-Tuple{Any, Int64}","page":"API Reference","title":"WhatsThePoint._build_knn_neighbors","text":"_build_knn_neighbors(points, k::Int) -> Vector{Vector{Int}}\n\nBuild k-nearest neighbor adjacency list from points.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._build_radius_neighbors-Tuple{Any, Any}","page":"API Reference","title":"WhatsThePoint._build_radius_neighbors","text":"_build_radius_neighbors(points, radius) -> Vector{Vector{Int}}\n\nBuild radius-based adjacency list from points.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._classify_empty_leaf_conservative-Union{Tuple{T}, Tuple{WhatsThePoint.SpatialOctree{Int64, T}, Meshes.SimpleMesh, Int64}} where T<:Real","page":"API Reference","title":"WhatsThePoint._classify_empty_leaf_conservative","text":"_classify_empty_leaf_conservative(tree, mesh, leaf_idx) -> Int8\n\nConservative classification for empty leaves.\n\n2 (interior): center and all 8 corners classify inside\n0 (exterior): center and all 8 corners classify outside\n1 (boundary): mixed results\n\nThis avoids falsely labeling a partially-outside leaf as interior.\n\nImplementation uses octree-accelerated signed distance, not ray casting.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._classify_leaves-Union{Tuple{T}, Tuple{WhatsThePoint.SpatialOctree{Int64, T}, Meshes.SimpleMesh}} where T<:Real","page":"API Reference","title":"WhatsThePoint._classify_leaves","text":"_classify_leaves(tree::SpatialOctree{Int,T}, mesh::SimpleMesh) -> Vector{Int8}\n\nClassify octree leaves as exterior (0), boundary (1), or interior (2).\n\nUses octree-accelerated signed distance for robust classification.\n\nReturns\n\nclassification::Vector{Int8}: Classification for each box\n-1: Internal node (not a leaf, unclassified)\n0: Exterior leaf\n1: Boundary leaf\n2: Interior leaf\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._collect_classified_leaves-Tuple{TriangleOctree}","page":"API Reference","title":"WhatsThePoint._collect_classified_leaves","text":"_collect_classified_leaves(octree::TriangleOctree)\n\nCollect interior and boundary leaves with their volumes from a classified octree.\n\nReturns (interior_leaves, interior_volumes, boundary_leaves, boundary_volumes).\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._compute_bbox-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh}} where T","page":"API Reference","title":"WhatsThePoint._compute_bbox","text":"_compute_bbox(::Type{T}, mesh::SimpleMesh) where {T} -> (bbox_min, bbox_max)\n\nCompute bounding box from mesh triangle data.\n\nPerformance: Single-pass min/max accumulation over all triangles.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._compute_local_signed_distance-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, Meshes.SimpleMesh, Vector{Int64}}} where T<:Real","page":"API Reference","title":"WhatsThePoint._compute_local_signed_distance","text":"_compute_local_signed_distance(\n    point::SVector{3,T},\n    mesh::SimpleMesh,\n    tri_indices::Vector{Int}\n) -> T\n\nCompute signed distance from point to nearest triangle in the local set.\n\nThis is the key performance optimization: instead of checking all M triangles, we only check the kâ‰ˆ10-50 triangles in the point's octree leaf.\n\nPerformance: Fused computation avoids redundant closest_point calculation.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._compute_signed_distance_octree-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, Meshes.SimpleMesh, WhatsThePoint.SpatialOctree{Int64, T}}} where T<:Real","page":"API Reference","title":"WhatsThePoint._compute_signed_distance_octree","text":"_compute_signed_distance_octree(point, mesh, tree) -> T\n\nCompute signed distance to the closest triangle using octree branch-and-bound.\n\nThis avoids global O(M) triangle scans by searching only relevant octree regions.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._create_root_octree-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh, Int64}} where T","page":"API Reference","title":"WhatsThePoint._create_root_octree","text":"_create_root_octree(::Type{T}, mesh::SimpleMesh, n_triangles::Int) where {T} -> SpatialOctree{Int,T}\n\nCreate root octree covering mesh bounding box with all triangles in root.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._edge_key-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T","page":"API Reference","title":"WhatsThePoint._edge_key","text":"_edge_key(v1::SVector{3,T}, v2::SVector{3,T}) where {T} -> Tuple\n\nCreate a canonical edge key from two vertices (order-independent). Uses component-wise comparison for consistent ordering.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._extract_vertex-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"API Reference","title":"WhatsThePoint._extract_vertex","text":"_extract_vertex(::Type{T}, vert) where {T} -> SVector{3,T}\n\nExtract coordinates from a Meshes.jl vertex to an SVector{3,T}.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._get_triangle_normal-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh, Int64}} where T","page":"API Reference","title":"WhatsThePoint._get_triangle_normal","text":"_get_triangle_normal(::Type{T}, mesh::SimpleMesh, tri_idx::Int) where {T} -> SVector{3,T}\n\nExtract and normalize triangle normal from mesh. Accesses mesh data on-the-fly.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._get_triangle_vertices-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh, Int64}} where T","page":"API Reference","title":"WhatsThePoint._get_triangle_vertices","text":"_get_triangle_vertices(::Type{T}, mesh::SimpleMesh, tri_idx::Int) where {T} -> (SVector{3,T}, SVector{3,T}, SVector{3,T})\n\nExtract triangle vertices from mesh as SVectors. Accesses mesh data on-the-fly.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._normalize_normal-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"API Reference","title":"WhatsThePoint._normalize_normal","text":"_normalize_normal(::Type{T}, n_vec) where {T} -> SVector{3,T}\n\nExtract and normalize a Meshes.jl Vec normal to a unit SVector{3,T}.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._subdivide_triangle_octree!-Union{Tuple{T}, Tuple{WhatsThePoint.SpatialOctree{Int64, T}, Meshes.SimpleMesh, Int64, WhatsThePoint.SubdivisionCriterion}} where T<:Real","page":"API Reference","title":"WhatsThePoint._subdivide_triangle_octree!","text":"_subdivide_triangle_octree!(tree, mesh, box_idx, criterion)\n\nRecursively subdivide a box in the triangle octree.\n\nFor each box that needs subdivision:\n\nCreate 8 child boxes\nFor each triangle in parent, find which children it intersects\nDistribute triangle indices to children\nRecursively subdivide children if they meet criteria\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._triangle_axis_test-Union{Tuple{T}, NTuple{5, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"API Reference","title":"WhatsThePoint._triangle_axis_test","text":"_triangle_axis_test(\n    axis::SVector{3,T},\n    v0::SVector{3,T},\n    v1::SVector{3,T},\n    v2::SVector{3,T},\n    half::SVector{3,T}\n) where {T<:Real} -> Bool\n\nInternal helper for triangle-box intersection separating axis test.\n\nTests if the projection intervals of the triangle vertices and box overlap along the given axis.\n\nArguments\n\naxis: Separating axis direction\nv0, v1, v2: Triangle vertices in box-centered coordinates\nhalf: Box half-extents\n\nReturns\n\ntrue if intervals overlap (potential intersection), false if separated\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.add_box!-Union{Tuple{E}, Tuple{WhatsThePoint.SpatialOctree{E}, Vararg{Int64, 5}}} where E","page":"API Reference","title":"WhatsThePoint.add_box!","text":"add_box!(octree::SpatialOctree, i::Int, j::Int, k::Int, N::Int, parent_idx::Int) -> Int\n\nAdd new box to octree. Returns box index.\n\nAutomatically grows arrays if capacity exceeded.\n\nArguments\n\ni, j, k: Integer coordinates at level N\nN: Refinement level (N=1 is root, N=2 is first subdivision, etc.)\nparent_idx: Index of parent box\n\nReturns\n\nIndex of newly created box\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.all_boxes-Tuple{WhatsThePoint.SpatialOctree}","page":"API Reference","title":"WhatsThePoint.all_boxes","text":"all_boxes(octree::SpatialOctree) -> Vector{Int}\n\nReturn indices of all boxes (leaves and internal nodes).\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.all_leaves-Tuple{WhatsThePoint.SpatialOctree}","page":"API Reference","title":"WhatsThePoint.all_leaves","text":"all_leaves(octree::SpatialOctree) -> Vector{Int}\n\nReturn indices of all leaf boxes.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.balance_octree!-Tuple{WhatsThePoint.SpatialOctree, WhatsThePoint.SubdivisionCriterion}","page":"API Reference","title":"WhatsThePoint.balance_octree!","text":"balance_octree!(octree::SpatialOctree, criterion::SubdivisionCriterion)\n\nEnforce 2:1 balance constraint across entire octree.\n\nIteratively subdivides boxes that violate the 2:1 constraint until all adjacent boxes differ by at most one refinement level.\n\nArguments\n\ncriterion: Subdivision criterion (only size constraints are enforced)\n\nAlgorithm\n\nCollect all leaves\nCheck each leaf for balance violations\nSubdivide violating neighbors (only respecting physical limits like h_min)\nRepeat until no violations\n\nNote\n\nUses can_subdivide (not should_subdivide) to ignore element count criteria\nBalancing is a geometric constraint, not an optimization decision\nMaximum iterations limit prevents infinite loops. If hit, tree may not be fully balanced.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.bounding_box-Union{Tuple{WhatsThePoint.SpatialOctree{E, T}}, Tuple{T}, Tuple{E}} where {E, T}","page":"API Reference","title":"WhatsThePoint.bounding_box","text":"bounding_box(octree::SpatialOctree) -> (SVector{3}, SVector{3})\n\nGet overall bounding box of tree (root box).\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.box_bounds-Union{Tuple{T}, Tuple{E}, Tuple{WhatsThePoint.SpatialOctree{E, T}, Int64}} where {E, T}","page":"API Reference","title":"WhatsThePoint.box_bounds","text":"box_bounds(octree::SpatialOctree, box_idx::Int) -> (SVector{3}, SVector{3})\n\nGet (mincorner, maxcorner) of box.\n\nReturns\n\nTuple of (mincorner, maxcorner) as SVector{3,C}\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.box_center-Union{Tuple{T}, Tuple{E}, Tuple{WhatsThePoint.SpatialOctree{E, T}, Int64}} where {E, T}","page":"API Reference","title":"WhatsThePoint.box_center","text":"box_center(octree::SpatialOctree, box_idx::Int) -> SVector{3}\n\nCompute spatial center of box using (i,j,k,N) coordinates.\n\nFormula\n\ncenter = origin + (2*[i,j,k] + 1) * box_size / 2\n\nwhere box_size = root_size / N\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.box_size","page":"API Reference","title":"WhatsThePoint.box_size","text":"box_size(tree::AbstractSpatialTree, box_idx::Int) -> Real\n\nGet edge length of box.\n\nRequired\n\nTrees must implement this function.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.box_size-Tuple{WhatsThePoint.SpatialOctree, Int64}","page":"API Reference","title":"WhatsThePoint.box_size","text":"box_size(octree::SpatialOctree, box_idx::Int) -> Real\n\nGet edge length of box.\n\nBox size at refinement level N is: root_size / N\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.can_subdivide","page":"API Reference","title":"WhatsThePoint.can_subdivide","text":"can_subdivide(criterion::SubdivisionCriterion, tree, box_idx) -> Bool\n\nCheck if box CAN be subdivided based on physical constraints only.\n\nUnlike should_subdivide, this ignores content-based criteria (like element count) and only checks physical limits (like minimum size). Used during balancing where subdivision is required for geometric correctness, not optimization.\n\nArguments\n\ncriterion: Subdivision criterion (only size constraints are checked)\ntree: Spatial tree\nbox_idx: Index of box to check\n\nReturns\n\ntrue if box can physically be subdivided, false if at minimum size limit.\n\nExample\n\n# For balancing, we only respect size limits\nif needs_balancing(leaf)\n    if can_subdivide(criterion, tree, leaf)\n        subdivide!(tree, leaf)\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.closest_point_on_triangle-Union{Tuple{T}, NTuple{4, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"API Reference","title":"WhatsThePoint.closest_point_on_triangle","text":"closest_point_on_triangle(\n    P::SVector{3,T},\n    v1::SVector{3,T},\n    v2::SVector{3,T},\n    v3::SVector{3,T}\n) where {T<:Real} -> SVector{3,T}\n\nCompute the closest point on triangle (v1, v2, v3) to point P.\n\nUses barycentric coordinate method from Ericson's \"Real-Time Collision Detection\". The closest point is computed by:\n\nProjecting P onto the triangle plane\nComputing barycentric coordinates\nClamping to triangle if outside\n\nAlgorithm\n\nThe triangle can be parameterized as:     T(u,v) = v1 + u(v2-v1) + v(v3-v1)  for u,v â‰¥ 0, u+v â‰¤ 1\n\nWe find the closest point by solving a constrained minimization problem.\n\nReturns\n\nPoint on triangle surface closest to P (may be on edge or vertex).\n\nReferences\n\nEricson, \"Real-Time Collision Detection\", Chapter 5.1.5\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.distance_point_triangle-Union{Tuple{T}, NTuple{4, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"API Reference","title":"WhatsThePoint.distance_point_triangle","text":"distance_point_triangle(\n    P::SVector{3,T},\n    v1::SVector{3,T},\n    v2::SVector{3,T},\n    v3::SVector{3,T}\n) where {T<:Real} -> T\n\nCompute unsigned distance from point P to triangle (v1, v2, v3).\n\nReturns\n\nUnsigned distance (always positive or zero)\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.distance_point_triangle-Union{Tuple{T}, NTuple{5, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"API Reference","title":"WhatsThePoint.distance_point_triangle","text":"distance_point_triangle(\n    P::SVector{3,T},\n    v1::SVector{3,T},\n    v2::SVector{3,T},\n    v3::SVector{3,T},\n    normal::SVector{3,T}\n) where {T<:Real} -> T\n\nCompute signed distance from point P to triangle (v1, v2, v3).\n\nThe distance is:\n\nPositive if P is on the side of the triangle that the normal points to\nNegative if P is on the opposite side\nZero if P is on the triangle plane\n\nAlgorithm\n\nFind closest point Q on triangle to P\nCompute distance ||P - Q||\nDetermine sign based on which side of triangle P is on\n\nArguments\n\nP: Query point\nv1, v2, v3: Triangle vertices in counterclockwise order\nnormal: Outward-pointing unit normal vector\n\nReturns\n\nSigned distance (positive = outside, negative = inside for closed surface)\n\nExample\n\nusing StaticArrays\n\n# Triangle in xy-plane\nv1 = SVector(0.0, 0.0, 0.0)\nv2 = SVector(1.0, 0.0, 0.0)\nv3 = SVector(0.0, 1.0, 0.0)\nnormal = SVector(0.0, 0.0, 1.0)\n\n# Point above triangle\nP = SVector(0.25, 0.25, 1.0)\nd = distance_point_triangle(P, v1, v2, v3, normal)\n# d â‰ˆ 1.0 (positive, on normal side)\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.find_boxes_at_coords-Tuple{WhatsThePoint.SpatialOctree, Vararg{Int64, 4}}","page":"API Reference","title":"WhatsThePoint.find_boxes_at_coords","text":"find_boxes_at_coords(octree::SpatialOctree, i_target::Int, j_target::Int, k_target::Int, N_target::Int) -> Vector{Int}\n\nFind box(es) at given (i,j,k,N) coordinates.\n\nIf exact match found at level Ntarget, returns [boxidx]\nIf location is covered by coarser box, returns [coarserboxidx]\nIf location is subdivided finer, returns all descendants at that location\n\nReturns\n\nVector of box indices covering the target location\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.find_leaf-Union{Tuple{T}, Tuple{E}, Tuple{WhatsThePoint.SpatialOctree{E, T}, StaticArraysCore.SVector{3, T}}} where {E, T}","page":"API Reference","title":"WhatsThePoint.find_leaf","text":"find_leaf(octree::SpatialOctree, point::SVector{3}) -> Int\n\nFind leaf box containing point. Returns box index.\n\nTraverses tree from root to leaf in O(log n) time.\n\nArguments\n\npoint: Query point in same coordinate system as octree\n\nReturns\n\nIndex of leaf box containing point\n\nThrows\n\nAssertionError if point is outside octree bounds\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.find_neighbor-Tuple{WhatsThePoint.SpatialOctree, Int64, Int64}","page":"API Reference","title":"WhatsThePoint.find_neighbor","text":"find_neighbor(octree::SpatialOctree, box_idx::Int, direction::Int) -> Vector{Int}\n\nFind neighbor(s) in given direction. Returns vector of neighbor indices.\n\nHandles 2:1 refinement level difference:\n\nIf neighbor exists at same level: returns [neighbor_idx]\nIf neighbor is subdivided (finer): returns children on shared face (up to 4)\nIf neighbor doesn't exist (boundary): returns empty vector\n\nArguments\n\nbox_idx: Box to find neighbor of\ndirection: Direction code (1-6, see neighbor_direction)\n\nReturns\n\nVector of neighbor box indices (may be empty if at boundary)\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.has_children","page":"API Reference","title":"WhatsThePoint.has_children","text":"has_children(tree::AbstractSpatialTree, box_idx::Int) -> Bool\n\nCheck if box has been subdivided.\n\nRequired\n\nTrees must implement this function.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.has_children-Tuple{WhatsThePoint.SpatialOctree, Int64}","page":"API Reference","title":"WhatsThePoint.has_children","text":"has_children(octree::SpatialOctree, box_idx::Int) -> Bool\n\nCheck if box has been subdivided.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.is_leaf","page":"API Reference","title":"WhatsThePoint.is_leaf","text":"is_leaf(tree::AbstractSpatialTree, box_idx::Int) -> Bool\n\nCheck if box is a leaf (has no children).\n\nRequired\n\nTrees must implement this function.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.is_leaf-Tuple{WhatsThePoint.SpatialOctree, Int64}","page":"API Reference","title":"WhatsThePoint.is_leaf","text":"is_leaf(octree::SpatialOctree, box_idx::Int) -> Bool\n\nCheck if box has no children.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.needs_balancing-Tuple{WhatsThePoint.SpatialOctree, Int64}","page":"API Reference","title":"WhatsThePoint.needs_balancing","text":"needs_balancing(octree::SpatialOctree, box_idx::Int) -> Bool\n\nCheck if subdividing this box would violate 2:1 balance with any neighbor.\n\nReturns true if any neighbor has grandchildren (2-level refinement difference).\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.neighbor_direction-Tuple{Int64}","page":"API Reference","title":"WhatsThePoint.neighbor_direction","text":"neighbor_direction(direction::Int) -> (Int, Int, Int)\n\nConvert direction code to (di, dj, dk) offset.\n\nDirection Codes\n\n1: -x (left)\n2: +x (right)\n3: -y (bottom)\n4: +y (top)\n5: -z (front)\n6: +z (back)\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.num_elements-Tuple{WhatsThePoint.SpatialOctree}","page":"API Reference","title":"WhatsThePoint.num_elements","text":"num_elements(octree::SpatialOctree) -> Int\n\nTotal number of elements stored in tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.should_subdivide","page":"API Reference","title":"WhatsThePoint.should_subdivide","text":"should_subdivide(criterion::SubdivisionCriterion, tree, box_idx) -> Bool\n\nDetermine if box should be subdivided based on criterion.\n\nArguments\n\ncriterion: Subdivision criterion to evaluate\ntree: Spatial tree\nbox_idx: Index of box to check\n\nReturns\n\ntrue if box should be subdivided, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.subdivide!-Tuple{WhatsThePoint.SpatialOctree, Int64}","page":"API Reference","title":"WhatsThePoint.subdivide!","text":"subdivide!(octree::SpatialOctree, box_idx::Int) -> SVector{8,Int}\n\nSubdivide box into 8 children. Returns child indices [1:8].\n\nChild Ordering (Standard Octree Convention)\n\n1: (0,0,0) - bottom-left-front   (x-, y-, z-) 2: (1,0,0) - bottom-right-front  (x+, y-, z-) 3: (0,1,0) - top-left-front      (x-, y+, z-) 4: (1,1,0) - top-right-front     (x+, y+, z-) 5: (0,0,1) - bottom-left-back    (x-, y-, z+) 6: (1,0,1) - bottom-right-back   (x+, y-, z+) 7: (0,1,1) - top-left-back       (x-, y+, z+) 8: (1,1,1) - top-right-back      (x+, y+, z+)\n\nArguments\n\nbox_idx: Index of box to subdivide (must be leaf)\n\nReturns\n\nSVector{8,Int} of child indices in standard order\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.triangle_box_intersection-Union{Tuple{T}, NTuple{5, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"API Reference","title":"WhatsThePoint.triangle_box_intersection","text":"triangle_box_intersection(\n    v1::SVector{3,T},\n    v2::SVector{3,T},\n    v3::SVector{3,T},\n    box_min::SVector{3,T},\n    box_max::SVector{3,T}\n) where {T<:Real} -> Bool\n\nTest if triangle (v1, v2, v3) intersects axis-aligned box.\n\nUses the Separating Axis Theorem (SAT) with 13 potential separating axes:\n\n3 box face normals (x, y, z axes)\n1 triangle normal\n9 edge-edge cross products\n\nIf any axis separates the triangle and box, they don't intersect.\n\nAlgorithm\n\nTranslate triangle and box so box is centered at origin\nTest each potential separating axis\nReturn false if any axis separates, true otherwise\n\nReferences\n\nAkenine-MÃ¶ller, \"Fast 3D Triangle-Box Overlap Testing\" (2001)\nEricson, \"Real-Time Collision Detection\", Chapter 5.2.9\n\nPerformance\n\nOptimized with early-out tests. Average case is much faster than worst case.\n\n\n\n\n\n","category":"method"},{"location":"concepts/#Concepts","page":"Concepts","title":"Concepts","text":"This page explains the core design decisions and type hierarchy behind WhatsThePoint.jl.","category":"section"},{"location":"concepts/#Type-Hierarchy","page":"Concepts","title":"Type Hierarchy","text":"WhatsThePoint builds point clouds through composition:\n\nPointSurface     â€” Points with normals and areas (one contiguous surface)\n    â†“\nPointBoundary    â€” Named collection of surfaces forming a closed boundary\n    â†“\nPointCloud       â€” Boundary + volume points + optional topology\n\nAll geometric types inherit from Domain{M,C} where M<:Manifold describes the geometric space (currently Euclidean: ð”¼{2} or ð”¼{3}) and C<:CRS is the coordinate reference system (Cartesian, Cylindrical, Polar, etc.). This parameterization comes from Meshes.jl and enables type stability and proper dispatch.\n\n# A 3D point cloud in Cartesian coordinates on a Euclidean manifold:\nPointCloud{ð”¼{3}, Cartesian3D}","category":"section"},{"location":"concepts/#Surface-Elements","page":"Concepts","title":"Surface Elements","text":"Each boundary point is stored as a SurfaceElement containing:\n\npoint â€” The geometric position (face center of the imported mesh, not a vertex)\nnormal â€” Outward-pointing unit normal vector\narea â€” Associated surface area\n\nA PointSurface stores its elements as a StructArray{SurfaceElement}, giving column-oriented memory layout. This means iterating over all normals reads contiguous memory rather than striding through interleaved fields â€” a significant cache performance advantage when processing thousands of surface elements.","category":"section"},{"location":"concepts/#Immutability-and-Functional-API","page":"Concepts","title":"Immutability and Functional API","text":"Most types in WhatsThePoint are immutable. Operations return new objects rather than mutating in place:\n\n# set_topology returns a new cloud â€” the original is unchanged\ncloud2 = set_topology(cloud, KNNTopology, 21)\n\n# repel returns a new cloud (with NoTopology, since points moved)\ncloud3, convergence = repel(cloud2, spacing)\n\nThis design ensures compatibility with automatic differentiation frameworks and prevents stale state â€” if points move, the old topology object simply isn't used.\n\nExceptions: split_surface! and combine_surfaces! mutate a PointBoundary's internal surface dictionary. These are in-place operations by convention (indicated by the ! suffix) because they only reorganize existing surfaces without changing any point data.","category":"section"},{"location":"concepts/#Topology","page":"Concepts","title":"Topology","text":"Topology represents point connectivity â€” the neighbor stencils used by meshless solvers.\n\nType hierarchy:\n\nAbstractTopology â€” Abstract base with storage type parameter\nNoTopology â€” Singleton default (no connectivity computed)\nKNNTopology â€” k-nearest neighbor connectivity\nRadiusTopology â€” All neighbors within a fixed radius\n\nLocal vs global indices: Topology on a PointSurface or PointVolume uses local indices (1 through length(surf)). Topology on a PointCloud uses global indices (1 through length(cloud)), where boundary points come first, followed by volume points.\n\n# Surface topology â€” local indices\nsurf = set_topology(surf, KNNTopology, 10)\nneighbors(surf, 3)  # indices into surf, e.g. [1, 4, 7, ...]\n\n# Cloud topology â€” global indices\ncloud = set_topology(cloud, KNNTopology, 21)\nneighbors(cloud, 3) # indices into cloud, e.g. [1, 2, 5, 102, ...]\n\nTopology is computed eagerly when set_topology is called and is never automatically invalidated. Operations that move points (like repel) return objects with NoTopology â€” call set_topology again after repulsion.","category":"section"},{"location":"concepts/#Units","page":"Concepts","title":"Units","text":"WhatsThePoint integrates with Unitful.jl. Physical units work directly throughout the API:\n\nspacing = ConstantSpacing(1mm)\ncloud = set_topology(cloud, RadiusTopology, 2mm)\nsplit_surface!(boundary, 75Â°)\n\nUnits propagate through all operations â€” point coordinates, normals, areas, and spacing values all carry their units consistently.","category":"section"},{"location":"concepts/#Parallelism","page":"Concepts","title":"Parallelism","text":"WhatsThePoint uses OhMyThreads.jl for threaded execution. The following operations are parallelized:\n\nNormal computation and orientation (compute_normals, orient_normals!)\nPoint-in-volume testing (isinside)\nNode repulsion (repel)\nOctree queries and construction\n\nTo use multiple threads, start Julia with:\n\njulia -t auto    # use all available cores\njulia -t 8       # use 8 threads\n\nNo code changes are needed â€” parallel execution is automatic when threads are available.","category":"section"},{"location":"concepts/#Euclidean-Assumption","page":"Concepts","title":"Euclidean Assumption","text":"WhatsThePoint currently supports Euclidean manifolds only (ð”¼{2} and ð”¼{3}). Functions like compute_normals, orient_normals!, discretize, repel, and isinside have explicit Euclidean type constraints.\n\nAny coordinate system (Cartesian, Cylindrical, Polar, etc.) is supported on a Euclidean manifold â€” the constraint is about geometric structure (flat space), not coordinate representation.\n\nThe type system is designed so that non-Euclidean geometries (spherical, hyperbolic) can be added in the future through new method dispatches with appropriate geodesic operations.","category":"section"},{"location":"repel/#Node-Repulsion","page":"Node Repulsion","title":"Node Repulsion","text":"","category":"section"},{"location":"repel/#Why-Repulsion-Matters","page":"Node Repulsion","title":"Why Repulsion Matters","text":"Meshless PDE methods (RBF-FD, generalized finite differences) are sensitive to point distribution quality. Irregular spacing leads to poorly conditioned interpolation matrices and reduced accuracy. Node repulsion iteratively pushes points apart to achieve a more uniform distribution while respecting the domain boundary.","category":"section"},{"location":"repel/#Usage","page":"Node Repulsion","title":"Usage","text":"cloud, convergence = repel(cloud, spacing; Î²=0.2, max_iters=1000)\n\nrepel returns a tuple of (new_cloud, convergence_vector). The new cloud has NoTopology since points have moved â€” call set_topology again after repulsion.\n\nnote: Boundary points are fixed\nOnly volume (interior) points are moved during repulsion. Boundary points remain in place to preserve the original surface geometry.\n\nnote: Points pushed outside are removed\nAt each iteration, any volume point that has been pushed outside the domain boundary is automatically filtered out via isinside. This means the total point count may decrease slightly after repulsion.","category":"section"},{"location":"repel/#Parameters","page":"Node Repulsion","title":"Parameters","text":"Parameter Default Description\nÎ² 0.2 Repulsion strength â€” controls force magnitude\nÎ± 0.05 Ã— min(spacing) Step size â€” distance points move per iteration\nk 21 Number of nearest neighbors used in repulsion stencil\nmax_iters 1000 Maximum number of repulsion iterations\ntol 1e-6 Convergence tolerance on relative point movement","category":"section"},{"location":"repel/#Tuning-Guide","page":"Node Repulsion","title":"Tuning Guide","text":"Î² (repulsion strength): Values in the range 0.1â€“0.5 work well for most problems. Smaller values give gentler repulsion (slower convergence, more stable). Larger values produce stronger forces (faster convergence, risk of oscillation).\nk (neighbor count): Should roughly match the stencil size your meshless solver will use. Too small and points only feel local pressure; too large and the computation slows without benefit.\nÎ± (step size): The default (5% of minimum spacing) is conservative. Increase for faster convergence on well-behaved geometries; decrease if points escape the domain.\nmax_iters: 1000 is usually sufficient. Check the convergence vector to see if more iterations are needed.","category":"section"},{"location":"repel/#Algorithm-Details","page":"Node Repulsion","title":"Algorithm Details","text":"Each iteration:\n\nBuild a k-nearest neighbor tree of all points\nFor each point, compute a repulsive force from its k neighbors using\n\nF(r) = frac1(r^2 + beta)^2\n\nwhere r is the distance to a neighbor. The Î² parameter prevents singularity at r = 0 and controls the force shape.\n\nMove each point by Î± in the direction of the net repulsive force\nFilter out any points that have moved outside the domain using isinside\nRecord the maximum relative displacement as the convergence metric","category":"section"},{"location":"repel/#Convergence-Monitoring","page":"Node Repulsion","title":"Convergence Monitoring","text":"The convergence vector records the maximum relative point displacement at each iteration:\n\ncloud, conv = repel(cloud, spacing; Î²=0.2, max_iters=500)\n\n# Check if converged\nprintln(\"Final displacement: \", conv[end])\nprintln(\"Iterations used: \", length(conv))\n\nIf conv[end] is still large (say > 1e-3), the distribution may benefit from more iterations or parameter tuning.\n\n(Image: Repulsion before and after)","category":"section"},{"location":"repel/#Verifying-Distribution-Quality","page":"Node Repulsion","title":"Verifying Distribution Quality","text":"Use metrics to quantify the point distribution before and after repulsion:\n\n# Before repulsion\nmetrics(cloud)\n\n# After repulsion\ncloud_repelled, conv = repel(cloud, spacing)\nmetrics(cloud_repelled)\n\nmetrics prints the average, standard deviation, maximum, and minimum distances to each point's k nearest neighbors. A lower standard deviation indicates a more uniform distribution.","category":"section"},{"location":"repel/#Reference","page":"Node Repulsion","title":"Reference","text":"Miotti, M. (2023). Node repulsion for meshless discretizations.","category":"section"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/#Installation","page":"Quick Start","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/JuliaMeshless/WhatsThePoint.jl\")","category":"section"},{"location":"quickstart/#3D-Example:-Surface-Mesh-to-Solver-Ready-Point-Cloud","page":"Quick Start","title":"3D Example: Surface Mesh to Solver-Ready Point Cloud","text":"using WhatsThePoint\n\n# 1. Import a surface mesh\nboundary = PointBoundary(\"model.stl\")\n\n# 2. Split into named surfaces by normal angle\nsplit_surface!(boundary, 75Â°)\n\n# 3. Generate volume points\nspacing = ConstantSpacing(1mm)\ncloud = discretize(boundary, spacing; alg=VanDerSandeFornberg())\n\n# 4. Optimize point distribution\ncloud, convergence = repel(cloud, spacing)\n\n# 5. Build neighbor connectivity\ncloud = set_topology(cloud, KNNTopology, 21)\n\n# 6. Ready for your meshless solver\nneighbors(cloud, 1)  # neighbor indices for point 1","category":"section"},{"location":"quickstart/#2D-Example:-Polygon-to-Point-Cloud","page":"Quick Start","title":"2D Example: Polygon to Point Cloud","text":"using WhatsThePoint\n\n# 1. Define a 2D polygon boundary (unit square)\npts = Point.([(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)])\nboundary = PointBoundary(pts)\n\n# 2. Discretize with FornbergFlyer (2D algorithm)\nspacing = ConstantSpacing(0.05m)\ncloud = discretize(boundary, spacing; alg=FornbergFlyer())\n\n# 3. Optimize and connect\ncloud, convergence = repel(cloud, spacing)\ncloud = set_topology(cloud, KNNTopology, 9)\n\n(Image: 2D discretization)","category":"section"},{"location":"quickstart/#Visualization","page":"Quick Start","title":"Visualization","text":"using GLMakie\n\nvisualize(cloud; markersize=0.15)","category":"section"},{"location":"quickstart/#Next-Steps","page":"Quick Start","title":"Next Steps","text":"Guide â€” Full workflow walkthrough with explanations\nConcepts â€” Type hierarchy, design decisions, and units\nDiscretization â€” Algorithm details and spacing options\nAPI Reference â€” Complete function reference","category":"section"},{"location":"boundary_normals/#Boundary-and-Normals","page":"Boundary & Normals","title":"Boundary & Normals","text":"This page covers operations on boundary surfaces: normal computation and orientation, surface splitting and combining, and shadow point generation.","category":"section"},{"location":"boundary_normals/#Normal-Computation","page":"Boundary & Normals","title":"Normal Computation","text":"Normals are computed via PCA on local neighborhoods (Hoppe et al. 1992). For each point, a k-nearest neighbor set is found, the covariance matrix of the local neighborhood is formed, and the eigenvector corresponding to the smallest eigenvalue gives the normal direction.\n\nnormals = compute_normals(points, k)\n\nThe parameter k controls the neighborhood size â€” larger values produce smoother normals but may miss sharp features.","category":"section"},{"location":"boundary_normals/#Normal-Orientation","page":"Boundary & Normals","title":"Normal Orientation","text":"After computation, normals point in arbitrary directions (PCA gives an axis, not a direction). Consistent orientation uses a minimum spanning tree with DFS traversal:\n\nBuild a k-nearest neighbor graph weighted by 1 - |náµ¢ â‹… nâ±¼| (normals pointing similarly have low weight)\nCompute the minimum spanning tree\nStart from the point with the highest coordinate value (guaranteed to be on the convex hull)\nDFS through the MST, flipping each normal to agree with its parent\n\norient_normals!(normals, points, k)\n\nTo recompute and orient normals on an existing boundary in one step:\n\nupdate_normals!(boundary, k)","category":"section"},{"location":"boundary_normals/#Surface-Splitting","page":"Boundary & Normals","title":"Surface Splitting","text":"Identify distinct geometric faces (walls, inlets, outlets) so you can apply different boundary conditions to each.\n\nsplit_surface! divides a surface into sub-surfaces based on normal angle discontinuities:\n\nBuild a k-nearest neighbor graph on the surface points\nRemove edges where the angle between adjacent normals exceeds the threshold\nFind connected components in the pruned graph\nEach connected component becomes a new named surface\n\nsplit_surface!(boundary, 75Â°)\n\n# Check the result\nnames(boundary)  # e.g. [\"surface_1\", \"surface_2\", \"surface_3\"]","category":"section"},{"location":"boundary_normals/#Surface-Combining","page":"Boundary & Normals","title":"Surface Combining","text":"Merge multiple named surfaces back into one:\n\ncombine_surfaces!(boundary, \"surface_1\", \"surface_2\")\n\nThe first name is kept and the second surface is merged into it.","category":"section"},{"location":"boundary_normals/#Shadow-Points","page":"Boundary & Normals","title":"Shadow Points","text":"Shadow points are virtual points offset inward from the boundary along the normal direction. They are used in some meshless methods for enforcing boundary conditions (e.g., Hermite-type RBF-FD).\n\nConstant offset:\n\nshadow = ShadowPoints(0.5mm)\nshadow_pts = generate_shadows(surf, shadow)\n\nVariable offset (function of position):\n\nshadow = ShadowPoints(p -> spacing(p), 1)  # order parameter\nshadow_pts = generate_shadows(surf, shadow)\n\nThe offset is applied in the inward direction (opposite to the outward normal).","category":"section"},{"location":"boundary_normals/#References","page":"Boundary & Normals","title":"References","text":"Hoppe, H., DeRose, T., Duchamp, T., McDonald, J., & Stuetzle, W. (1992). Surface reconstruction from unorganized points. SIGGRAPH '92.","category":"section"},{"location":"discretization/#Discretization","page":"Discretization","title":"Discretization","text":"Volume discretization generates interior points from a boundary surface. This is typically the second step in the workflow after importing a surface mesh â€” see the Guide for the full pipeline.\n\ncloud = discretize(boundary, spacing; alg=algorithm, max_points=10_000_000)\n\nThe max_points parameter is a safety limit that prevents runaway point generation. It defaults to 10 million. If your target spacing would produce more points than this limit, discretization stops early.","category":"section"},{"location":"discretization/#Algorithm-Overview","page":"Discretization","title":"Algorithm Overview","text":"Algorithm Dimensions Spacing Required Description\nSlakKosec 3D Yes Sphere-based candidate generation\nVanDerSandeFornberg 3D Yes (ConstantSpacing only) Grid projection with sphere packing\nFornbergFlyer 2D Yes (ConstantSpacing only) 1D projection with height-field fill\nOctreeRandom 3D No Octree-guided random point generation\n\n(Image: Algorithm comparison)","category":"section"},{"location":"discretization/#Choosing-an-Algorithm","page":"Discretization","title":"Choosing an Algorithm","text":"2D problems: Use FornbergFlyer â€” it is the only 2D algorithm and is selected by default for 2D boundaries.\n3D with variable spacing: Use SlakKosec â€” it is the only 3D algorithm supporting LogLike spacing.\n3D with uniform spacing: SlakKosec (default) or VanDerSandeFornberg both work. SlakKosec is more general; VanDerSandeFornberg can be faster for simple geometries.\nLarge 3D meshes: Use OctreeRandom or pass a TriangleOctree to SlakKosec for accelerated isinside queries. See the Point-in-Volume & Octree page.","category":"section"},{"location":"discretization/#SlakKosec","page":"Discretization","title":"SlakKosec","text":"Default algorithm for 3D discretization. Generates candidate points on spheres around existing points, accepting those that are inside the domain and sufficiently far from existing points.\n\n# Basic usage\ncloud = discretize(boundary, spacing; alg=SlakKosec())\n\n# Custom number of candidates per sphere (default: 10)\ncloud = discretize(boundary, spacing; alg=SlakKosec(20))\n\n# With octree acceleration for faster isinside queries\noctree = TriangleOctree(\"model.stl\"; h_min=0.5)\ncloud = discretize(boundary, spacing; alg=SlakKosec(octree))\ncloud = discretize(boundary, spacing; alg=SlakKosec(20, octree))\n\nSupports both ConstantSpacing and variable spacings (LogLike).","category":"section"},{"location":"discretization/#VanDerSandeFornberg","page":"Discretization","title":"VanDerSandeFornberg","text":"3D algorithm that projects a 2D grid onto the shadow plane and fills the volume layer by layer using sphere packing heights.\n\ncloud = discretize(boundary, ConstantSpacing(1mm); alg=VanDerSandeFornberg())\n\nRequires ConstantSpacing. Uses isinside (Green's function) for filtering generated points.","category":"section"},{"location":"discretization/#FornbergFlyer","page":"Discretization","title":"FornbergFlyer","text":"2D-only algorithm. Uses a similar height-field approach as VanDerSandeFornberg, but projects onto the x-axis for 2D domains.\n\ncloud = discretize(boundary, ConstantSpacing(0.1mm); alg=FornbergFlyer())\n\nThis is the default (and only) algorithm for 2D boundaries.","category":"section"},{"location":"discretization/#OctreeRandom","page":"Discretization","title":"OctreeRandom","text":"Generates volume points directly from an octree decomposition of the domain. The octree classifies leaf nodes as interior, boundary, or exterior. Interior leaves are filled with random points directly (100% acceptance rate), while boundary leaves are oversampled and filtered with the octree-accelerated isinside test.\n\nNo spacing parameter is needed â€” point density is controlled by the octree resolution (h_min).\n\n# From a mesh file (recommended â€” auto-computes h_min)\ncloud = discretize(boundary, OctreeRandom(\"model.stl\"))\n\n# With explicit h_min\ncloud = discretize(boundary, OctreeRandom(\"model.stl\"; h_min=0.5))\n\n# From a pre-built TriangleOctree\noctree = TriangleOctree(\"model.stl\"; h_min=0.5)\ncloud = discretize(boundary, OctreeRandom(octree))\n\n# With custom boundary oversampling (default: 2.0)\ncloud = discretize(boundary, OctreeRandom(octree, 3.0))\n\nParameters:\n\nh_min â€” Minimum octree box size. Auto-computed from mesh diagonal and triangle count if omitted.\nmax_triangles_per_box â€” Maximum triangles per leaf before subdivision (default: 50).\nboundary_oversampling â€” Oversampling factor for boundary leaves (default: 2.0). Higher values improve boundary coverage at the cost of more rejected candidates.\nverify_interior â€” Verify generated interior points with isinside (default: false). Usually unnecessary since leaf classification is reliable.\nverify_orientation â€” Check mesh normal consistency before building the octree (default: true).","category":"section"},{"location":"discretization/#Spacing-Types","page":"Discretization","title":"Spacing Types","text":"Spacing controls point density for algorithms that require it (all except OctreeRandom).","category":"section"},{"location":"discretization/#ConstantSpacing","page":"Discretization","title":"ConstantSpacing","text":"Uniform spacing everywhere in the domain:\n\nspacing = ConstantSpacing(1mm)\n\nWorks with all algorithms.","category":"section"},{"location":"discretization/#LogLike","page":"Discretization","title":"LogLike","text":"Variable spacing that is denser near the boundary and coarser in the interior. Uses a logarithmic-like growth function:\n\nspacing = LogLike(cloud, base_size, growth_rate)\n\ncloud â€” An existing PointCloud. LogLike uses the cloud's boundary points to compute distances, so you must first create a cloud with ConstantSpacing, then use LogLike for a second-pass refinement.\nbase_size â€” Spacing at the boundary surface.\ngrowth_rate â€” Rate at which spacing increases away from the boundary. Values > 1 create coarser interior points.\n\nThe spacing at a point is computed as base_size * x / (a + x) where x is the distance to the nearest boundary point.\n\nWorks with SlakKosec only.\n\nTypical workflow:\n\n# First pass with uniform spacing\ncloud = discretize(boundary, ConstantSpacing(1mm); alg=SlakKosec())\n\n# Second pass with variable spacing\nspacing = LogLike(cloud, 0.5mm, 1.2)\ncloud = discretize(boundary, spacing; alg=SlakKosec())","category":"section"},{"location":"discretization/#References","page":"Discretization","title":"References","text":"Slak, J. & Kosec, G. (2019). On generation of node distributions for meshless PDE discretizations. SIAM Journal on Scientific Computing, 41(5).\nVan der Sande, K. & Fornberg, B. (2021). Fast variable density 3-D node generation. SIAM Journal on Scientific Computing, 43(1).\nFornberg, B. & Flyer, N. (2015). Fast generation of 2-D node distributions for mesh-free PDE discretizations. Computers & Mathematics with Applications, 69(7).","category":"section"},{"location":"#WhatsThePoint.jl","page":"Home","title":"WhatsThePoint.jl","text":"Generate, optimize, and connect point clouds for meshless PDE methods.\n\nMeshless methods need well-distributed point clouds with neighbor connectivity, but getting from a CAD surface to solver-ready points is tedious. WhatsThePoint.jl handles the complete pipeline â€” from surface mesh import through volume discretization, point distribution optimization, and connectivity computation â€” in a few lines of Julia.","category":"section"},{"location":"#Pipeline-at-a-Glance","page":"Home","title":"Pipeline at a Glance","text":"Import Surface â€” Load STL/OBJ via GeoIO.jl into a PointBoundary\nSplit & Label â€” Identify walls, inlets, outlets by normal angle\nGenerate Volume â€” Fill the interior with well-spaced points\nOptimize Distribution â€” Node repulsion for solver accuracy\nBuild Connectivity â€” k-nearest neighbor or radius-based stencils\nReady for Solver â€” Export to VTK or pass directly to your meshless code","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"Load a surface mesh and inspect the boundary structure:\n\nusing WhatsThePoint\nboundary = PointBoundary(joinpath(@__DIR__, \"assets/bunny.stl\"))\n\nusing GLMakie\nvisualize(boundary; markersize=0.15)\n\n(Image: bunny boundary)\n\nGenerate volume points with discretize:\n\nspacing = ConstantSpacing(1m)\ncloud = discretize(boundary, spacing; alg=VanDerSandeFornberg(), max_points=100_000)\n\nvisualize(cloud; markersize=0.15)\n\n(Image: bunny discretized)","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/JuliaMeshless/WhatsThePoint.jl\")","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"Pipeline\n\nImport surface meshes (STL, OBJ, any GeoIO.jl format)\nMultiple discretization algorithms: SlakKosec, VanDerSandeFornberg (3D), FornbergFlyer (2D), OctreeRandom\nNode repulsion for distribution optimization (Miotti 2023)\nk-nearest neighbor and radius-based topology for meshless stencils\nExport to VTK\n\nPerformance\n\nTriangleOctree for O(1) point-in-volume queries on large meshes\nThreaded operations throughout via OhMyThreads.jl\nStructArray layout for cache-friendly surface element access\n\nCorrectness\n\nFull Unitful.jl integration â€” mm, m, Â° work directly\nType-safe geometry built on Meshes.jl with coordinate system support\nImmutable, AD-compatible design â€” operations return new objects\n\n\n\n(Image: Build Status) (Image: Stable) (Image: Dev) (Image: License File)","category":"section"},{"location":"isinside_octree/#Point-in-Volume-and-Octree","page":"Point-in-Volume & Octree","title":"Point-in-Volume & Octree","text":"WhatsThePoint provides three approaches for testing whether points lie inside a closed boundary, suited to different problem sizes and dimensions.","category":"section"},{"location":"isinside_octree/#Overview","page":"Point-in-Volume & Octree","title":"Overview","text":"Method Dimensions Complexity When to use\nWinding number 2D O(M) per query All 2D problems\nGreen's function 3D O(M) per query Small/medium meshes\nOctree-accelerated 3D O(1) most queries Large meshes (>10k triangles)\n\nM = number of boundary segments (2D) or triangles (3D).","category":"section"},{"location":"isinside_octree/#2D:-Winding-Number","page":"Point-in-Volume & Octree","title":"2D: Winding Number","text":"For 2D domains, isinside uses the winding number algorithm. It counts the number of times the boundary winds around a query point â€” nonzero winding number means the point is inside.","category":"section"},{"location":"isinside_octree/#3D:-Green's-Function","page":"Point-in-Volume & Octree","title":"3D: Green's Function","text":"For 3D domains without an octree, isinside uses a Green's function approach. The solid angle subtended by each boundary triangle at the query point is summed â€” a total of 4Ï€ means the point is inside. This is O(M) per query where M is the number of boundary triangles.","category":"section"},{"location":"isinside_octree/#3D:-Octree-Accelerated","page":"Point-in-Volume & Octree","title":"3D: Octree-Accelerated","text":"For large 3D meshes, the Green's function approach becomes expensive. The TriangleOctree accelerates queries to O(1) for most points by spatially decomposing the mesh and pre-classifying regions as interior or exterior.","category":"section"},{"location":"isinside_octree/#Building-a-TriangleOctree","page":"Point-in-Volume & Octree","title":"Building a TriangleOctree","text":"using WhatsThePoint\n\n# From a file path\noctree = TriangleOctree(\"model.stl\"; h_min=0.5)\n\n# From a SimpleMesh\nusing GeoIO\nmesh = GeoIO.load(\"model.stl\") |> boundary\noctree = TriangleOctree(mesh; h_min=0.5)\n\nParameters:\n\nh_min (required) â€” Minimum box size. Controls the finest resolution of the octree.\nmax_triangles_per_box â€” Maximum triangles per leaf before subdivision (default: 50).\nclassify_leaves â€” Whether to classify empty leaves as interior/exterior (default: true).\nverify_orientation â€” Check mesh normal consistency before building (default: true). Uses has_consistent_normals internally â€” if normals are inconsistent, the octree classification will be unreliable.","category":"section"},{"location":"isinside_octree/#Construction-Process","page":"Point-in-Volume & Octree","title":"Construction Process","text":"Create a root box enclosing the mesh bounding box (with a small buffer)\nDistribute triangles into leaves, subdividing when a leaf has too many triangles or is larger than h_min\nBalance the tree to enforce a 2:1 refinement constraint (no adjacent leaves differ by more than one level)\nClassify empty leaves as interior or exterior using signed distance queries","category":"section"},{"location":"isinside_octree/#Leaf-Classification","page":"Point-in-Volume & Octree","title":"Leaf Classification","text":"Each leaf in the octree is classified as one of:\n\nInterior â€” Entirely inside the mesh surface\nExterior â€” Entirely outside the mesh surface\nBoundary â€” Contains or is near the mesh surface\n\nThis classification enables O(1) point-in-volume queries for interior and exterior leaves.","category":"section"},{"location":"isinside_octree/#Octree-Accelerated-isinside","page":"Point-in-Volume & Octree","title":"Octree-Accelerated isinside","text":"octree = TriangleOctree(\"model.stl\"; h_min=0.5)\n\n# Single point query\nresult = isinside(point, octree)\n\n# Batch query\nresults = isinside(points, octree)\n\nPerformance: For interior and exterior leaves, the result is a direct array lookup â€” O(1). For boundary leaves, a local signed distance is computed using only the triangles in that leaf â€” O(k) where k is typically 10â€“50 triangles. This is dramatically faster than the default O(M) Green's function approach for large meshes.\n\nBoth SVector{3} and Meshes.jl Point types are accepted.","category":"section"},{"location":"isinside_octree/#Integration-with-Discretization","page":"Point-in-Volume & Octree","title":"Integration with Discretization","text":"","category":"section"},{"location":"isinside_octree/#SlakKosec-with-Octree","page":"Point-in-Volume & Octree","title":"SlakKosec with Octree","text":"Pass a TriangleOctree to SlakKosec to accelerate the isinside checks during volume point generation:\n\noctree = TriangleOctree(\"model.stl\"; h_min=0.5)\nspacing = ConstantSpacing(1mm)\ncloud = discretize(boundary, spacing; alg=SlakKosec(octree))","category":"section"},{"location":"isinside_octree/#Using-OctreeRandom","page":"Point-in-Volume & Octree","title":"Using OctreeRandom","text":"OctreeRandom uses the octree directly to generate volume points. See the Discretization page for details.\n\ncloud = discretize(boundary, OctreeRandom(\"model.stl\"; h_min=0.5))","category":"section"},{"location":"isinside_octree/#Choosing-an-Approach","page":"Point-in-Volume & Octree","title":"Choosing an Approach","text":"2D problems: The winding number is used automatically â€” no configuration needed.\nSmall 3D meshes (<10k triangles): The default Green's function works fine.\nLarge 3D meshes (>10k triangles): Build a TriangleOctree and pass it to isinside or SlakKosec for orders-of-magnitude speedup.\nWhen you need volume points directly: Use OctreeRandom to skip the separate isinside step entirely.","category":"section"},{"location":"isinside_octree/#Query-Functions","page":"Point-in-Volume & Octree","title":"Query Functions","text":"num_leaves(octree)                 # Number of leaf nodes\nnum_triangles(octree)              # Number of triangles in the mesh\nhas_consistent_normals(mesh)       # Check if mesh normals are consistently oriented\n\nnote: `has_consistent_normals`\nThis function checks whether a mesh has consistently oriented normals â€” a prerequisite for reliable interior/exterior classification. It is called automatically during TriangleOctree construction when verify_orientation=true (the default).","category":"section"}]
}
