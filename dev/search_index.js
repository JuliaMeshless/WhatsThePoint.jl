var documenterSearchIndex = {"docs":
[{"location":"api/#Exported-Functions","page":"API","title":"Exported Functions","text":"","category":"section"},{"location":"api/#Private","page":"API","title":"Private","text":"","category":"section"},{"location":"api/#WhatsThePoint.AbstractSurface","page":"API","title":"WhatsThePoint.AbstractSurface","text":"abstract type AbstractSurface{M<:Manifold,C<:CRS} end\n\nA surface of a PointSurface.\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.AbstractTopology","page":"API","title":"WhatsThePoint.AbstractTopology","text":"abstract type AbstractTopology{S}\n\nAbstract base type for point cloud topology (connectivity). Type parameter S is the storage format for neighbor indices.\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.ConstantSpacing","page":"API","title":"WhatsThePoint.ConstantSpacing","text":"ConstantSpacing{L<:Unitful.Length} <: AbstractSpacing\n\nConstant node spacing.\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.KNNTopology","page":"API","title":"WhatsThePoint.KNNTopology","text":"mutable struct KNNTopology{S} <: AbstractTopology{S}\n\nk-nearest neighbors topology.\n\nFields\n\nneighbors::S - neighbor indices storage\nk::Int - number of neighbors per point\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.LogLike","page":"API","title":"WhatsThePoint.LogLike","text":"LogLike <: VariableSpacing\n\nNode spacing based on a log-like function of the distance to nearest boundary x(x+a)     where x is the distance to the nearest boundary and a is a parameter to control     the growth rate as a = 1 - (g - 1) where g is the conventional growth rate     parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.NoTopology","page":"API","title":"WhatsThePoint.NoTopology","text":"struct NoTopology <: AbstractTopology{Nothing}\n\nSingleton type representing no topology. Default for PointCloud.\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.OctreeRandom","page":"API","title":"WhatsThePoint.OctreeRandom","text":"OctreeRandom <: AbstractNodeGenerationAlgorithm\n\nOctree-guided random point generation for volume discretization.\n\nThis algorithm uses a TriangleOctree with leaf classification to efficiently generate random points inside the mesh. It's much faster than rejection sampling because:\n\nOnly samples in interior/boundary regions (skips exterior entirely)\nInterior boxes need no filtering (100% acceptance rate)\nOnly boundary boxes require isinside() checks\n\nFields\n\noctree::TriangleOctree - Octree with leaf classification\nboundary_oversampling::Float64 - Oversampling factor for boundary boxes (default: 2.0)\nverify_interior::Bool - Per-point signed distance verification for interior leaves (default: false)\n\nConstructors\n\n# From mesh (recommended) â€” builds octree automatically with classified leaves\nOctreeRandom(mesh::SimpleMesh)                          # Auto h_min\nOctreeRandom(mesh; h_min=0.01, boundary_oversampling=2.0)  # Custom h_min\n\n# From file path â€” loads mesh then builds octree\nOctreeRandom(\"bunny.stl\")\nOctreeRandom(\"bunny.stl\"; h_min=0.01)\n\n# From pre-built octree (advanced)\nOctreeRandom(octree::TriangleOctree)\nOctreeRandom(octree, oversampling; verify_interior=false)\n\nPerformance\n\nInterior leaves: O(1) per point (no filtering needed)\nBoundary leaves: O(k) per point where k â‰ˆ 10-50 triangles\nMuch faster than bounding box rejection: Typical acceptance 5-20% vs 90%+ here\n\nUsage Examples\n\nRecommended Usage\n\nusing WhatsThePoint\n\nmesh = GeoIO.load(\"bunny.stl\").geometry\nboundary = PointBoundary(mesh)\ncloud = discretize(boundary, OctreeRandom(mesh); max_points=100_000)\n\nWith Spacing (backward compatible)\n\noctree = TriangleOctree(mesh; h_min=0.01, classify_leaves=true)\ncloud = discretize(boundary, 1.0u\"m\"; alg=OctreeRandom(octree), max_points=10_000)\n\nWith Custom Oversampling\n\nalg = OctreeRandom(mesh; boundary_oversampling=2.5)\ncloud = discretize(boundary, alg; max_points=10_000)\n\nNotes\n\nThe mesh convenience constructor always sets classify_leaves=true\nWhen h_min is omitted, it is computed as bbox_diagonal / (2 * cbrt(n_triangles))\nThe spacing parameter is not used (random uniform distribution)\nFor spacing-based discretization, use SlakKosec or VanDerSandeFornberg\nActual point count may be slightly less than max_points due to boundary filtering\nOversampling 1.5-3.0 is recommended; higher values waste computation\n\nAlgorithm Details\n\nIdentify regions: Separate octree leaves into interior (2) and boundary (1)\nAllocate points: Distribute target count proportionally to leaf volumes\nGenerate interior points: Random sampling in interior boxes (no filtering)\nGenerate boundary points: Oversample and filter with isinside()\nReturn: Combined set of validated interior points\n\nWhen to Use\n\nGood for:\n\nQuick initial discretization\nUniform random distributions\nMaximum point count targets\nTesting and prototyping\n\nNot ideal for:\n\nSpacing-controlled discretization (use SlakKosec instead)\nAdaptive refinement\nSmooth point distributions\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.OctreeRandom-Tuple{String}","page":"API","title":"WhatsThePoint.OctreeRandom","text":"OctreeRandom(filepath::String; kwargs...)\n\nLoad a mesh from filepath and build an OctreeRandom algorithm. Accepts the same keyword arguments as OctreeRandom(mesh; ...).\n\nExample\n\nalg = OctreeRandom(\"bunny.stl\")\ncloud = discretize(boundary, alg; max_points=100_000)\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.OctreeRandom-Union{Tuple{Meshes.SimpleMesh{M, C, V} where V<:AbstractArray{Point{M, C}, 1}}, Tuple{C}, Tuple{M}} where {M<:Meshes.Manifold, C<:CoordRefSystems.CRS}","page":"API","title":"WhatsThePoint.OctreeRandom","text":"OctreeRandom(mesh::SimpleMesh; h_min=nothing, max_triangles_per_box=50,\n             boundary_oversampling=2.0, verify_interior=false, verify_orientation=true)\n\nConvenience constructor that builds a classified TriangleOctree internally.\n\nWhen h_min is not provided, an automatic value is computed from the mesh's bounding box diagonal and triangle count.\n\nExample\n\nmesh = GeoIO.load(\"bunny.stl\").geometry\nalg = OctreeRandom(mesh)\ncloud = discretize(boundary, alg; max_points=100_000)\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.PointBoundary","page":"API","title":"WhatsThePoint.PointBoundary","text":"struct PointBoundary{M,C} <: Domain{M,C}\n\nA boundary of points.\n\nFields\n\nsurfaces: Named surfaces forming the boundary\n\nType Parameters\n\nM <: Manifold: The manifold type\nC <: CRS: The coordinate reference system\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.PointBoundary-Tuple{Meshes.SimpleMesh}","page":"API","title":"WhatsThePoint.PointBoundary","text":"PointBoundary(mesh::SimpleMesh)\n\nCreate a PointBoundary from a SimpleMesh  by taking the centroids of its elements as points,  and computing normals and areas accordingly.\n\n(IMPORTANT: does not use any fancy node sampling,  depends on the mesh's discretization, and is not guaranteed  to be a good representation of the original geometry.  Use with caution.)\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.PointCloud","page":"API","title":"WhatsThePoint.PointCloud","text":"struct PointCloud{M,C,T} <: Domain{M,C}\n\nA point cloud with optional topology (connectivity).\n\nType Parameters\n\nM<:Manifold - manifold type\nC<:CRS - coordinate reference system\nT<:AbstractTopology - topology type for cloud-level connectivity\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.PointSurface","page":"API","title":"WhatsThePoint.PointSurface","text":"struct PointSurface{M,C,S,T} <: AbstractSurface{M,C}\n\nThis is a typical representation of a surface via points.\n\nType Parameters\n\nM<:Manifold - manifold type\nC<:CRS - coordinate reference system\nS - shadow type\nT<:AbstractTopology - topology type for surface-local connectivity\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.PointVolume","page":"API","title":"WhatsThePoint.PointVolume","text":"struct PointVolume{M,C,T,V} <: Domain{M,C}\n\nInterior volume points with optional topology.\n\nType Parameters\n\nM<:Manifold - manifold type\nC<:CRS - coordinate reference system\nT<:AbstractTopology - topology type for volume-local connectivity\nV<:AbstractVector{Point{M,C}} - storage type (allows GPU arrays)\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.Power","page":"API","title":"WhatsThePoint.Power","text":"Power <: VariableSpacing\n\nNode spacing based on a power of the distance to nearest boundary x^g where x is     the distance to the nearest boundary and g is the growth_rate.\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.RadiusTopology","page":"API","title":"WhatsThePoint.RadiusTopology","text":"mutable struct RadiusTopology{S,R} <: AbstractTopology{S}\n\nRadius-based topology where neighbors are all points within a given radius.\n\nFields\n\nneighbors::S - neighbor indices storage\nradius::R - search radius (scalar or function of position)\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.SlakKosec","page":"API","title":"WhatsThePoint.SlakKosec","text":"SlakKosec <: AbstractNodeGenerationAlgorithm\n\nSlak-Kosec algorithm for volume point generation with optional octree acceleration.\n\nThe algorithm generates candidate points on spheres around existing points and accepts them if they are inside the domain and sufficiently far from existing points.\n\nFields\n\nn::Int - Number of candidate points per sphere (default: 10)\noctree::Union{Nothing,TriangleOctree} - Optional octree for fast isinside queries\n\nConstructors\n\nSlakKosec()                          # Default: n=10, no octree\nSlakKosec(20)                        # Custom n, no octree\nSlakKosec(octree::TriangleOctree)    # Use octree acceleration with n=10\nSlakKosec(20, octree)                # Custom n with octree acceleration\n\nPerformance\n\nWithout octree: Uses Green's function for isinside (~50ms per query)\nWith octree: Uses spatial indexing (~0.05ms per query, 1000Ã— faster!)\n\nUsage Examples\n\nStandard Usage (Green's function)\n\nusing WhatsThePoint\n\n# Load boundary\nboundary = PointBoundary(\"model.stl\")\ncloud = PointCloud(boundary)\n\n# Discretize without octree (slow for large domains)\nspacing = ConstantSpacing(1.0u\"m\")\nresult = discretize(cloud, spacing; alg=SlakKosec(), max_points=10_000)\n\nOctree-Accelerated Usage (Recommended for large domains)\n\nusing WhatsThePoint\n\n# Load boundary points\nboundary = PointBoundary(\"model.stl\")\ncloud = PointCloud(boundary)\n\n# Build octree from STL file (Option 1: simplest)\noctree = TriangleOctree(\"model.stl\"; h_min=0.01, classify_leaves=true)\n\n# Or from SimpleMesh (Option 2)\n# mesh = GeoIO.load(\"model.stl\").geometry\n# octree = TriangleOctree(mesh; h_min=0.01, classify_leaves=true)\n\n# Use octree-accelerated discretization (100-1000Ã— faster!)\nspacing = ConstantSpacing(1.0u\"m\")\nalg = SlakKosec(octree)  # Pass octree to algorithm\nresult = discretize(cloud, spacing; alg=alg, max_points=100_000)\n\nReferences\n\nÅ lak J, Kosec G. \"On generation of node distributions for meshless PDE discretizations\" (2019)\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.SurfaceElement","page":"API","title":"WhatsThePoint.SurfaceElement","text":"struct SurfaceElement{M,C,N,A}\n\nRepresentation of a point on a <:PointSurface.\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.TriangleOctree","page":"API","title":"WhatsThePoint.TriangleOctree","text":"TriangleOctree{M<:Manifold, C<:CRS, T<:Real}\n\nAn octree-based spatial index for efficient triangle mesh queries.\n\nFields\n\ntree::SpatialOctree{Int,T}: Underlying octree storing triangle indices\nmesh::SimpleMesh{M,C}: Original Meshes.jl mesh (single source of truth for triangle data)\nleaf_classification::Union{Nothing, Vector{Int8}}: Classification of empty leaves\n0: Exterior (outside mesh)\n1: Boundary (near surface but empty)\n2: Interior (inside mesh)\n\nPerformance\n\nFor a mesh with M triangles:\n\nConstruction: O(M log M) - distribute triangles to boxes\nQuery: O(log M + k) where k â‰ˆ 10-50 triangles per leaf\nMemory: O(N) for octree nodes (mesh data accessed on-the-fly)\n\nExample\n\n# Option 1: From STL file (simplest)\noctree = TriangleOctree(\"model.stl\"; h_min=0.01, classify_leaves=true)\n\n# Option 2: From SimpleMesh\nmesh = GeoIO.load(\"model.stl\").geometry\noctree = TriangleOctree(mesh; h_min=0.01, classify_leaves=true)\n\n# Fast queries (100-1000x speedup over brute force)\npoint = SVector(0.5, 0.5, 0.5)\nis_inside = isinside(point, octree)\n\nWorkflow with PointBoundary\n\nSince PointBoundary discards mesh topology, build both from the same mesh:\n\nmesh = GeoIO.load(\"model.stl\").geometry\nboundary = PointBoundary(mesh)\noctree = TriangleOctree(mesh; h_min=0.01, classify_leaves=true)\ncloud = discretize(boundary, spacing; alg=OctreeRandom(octree))\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.TriangleOctree-Tuple{String}","page":"API","title":"WhatsThePoint.TriangleOctree","text":"TriangleOctree(filepath::String; h_min, kwargs...) -> TriangleOctree\n\nBuild an octree spatial index from an STL file.\n\nArguments\n\nfilepath::String: Path to STL file\nh_min: Minimum octree box size\nkwargs...: Additional arguments passed to TriangleOctree(mesh; ...)\n\nExample\n\noctree = TriangleOctree(\"model.stl\"; h_min=0.01, classify_leaves=true)\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.TriangleOctree-Union{Tuple{Meshes.SimpleMesh{M, C, V} where V<:AbstractArray{Point{M, C}, 1}}, Tuple{C}, Tuple{M}} where {M<:Meshes.Manifold, C<:CoordRefSystems.CRS}","page":"API","title":"WhatsThePoint.TriangleOctree","text":"TriangleOctree(mesh::SimpleMesh{M,C};\n               h_min,\n               max_triangles_per_box::Int=50,\n               classify_leaves::Bool=true,\n               verify_orientation::Bool=true) -> TriangleOctree{M,C,Float64}\n\nBuild an octree spatial index for a SimpleMesh.\n\nArguments\n\nmesh::SimpleMesh{M,C}: Meshes.jl SimpleMesh to index\nh_min: Minimum octree box size (stopping criterion)\nmax_triangles_per_box::Int=50: Maximum triangles per leaf before subdivision\nclassify_leaves::Bool=true: Whether to classify empty leaves as interior/exterior\nverify_orientation::Bool=true: Check if triangle normals are consistently oriented\n\nAlgorithm\n\n(Optional) Verify triangle normal consistency\nCreate root octree covering mesh bounding box\nDistribute triangles to boxes using SAT intersection tests\nRecursively subdivide boxes exceeding triangle threshold\nBalance octree to ensure 2:1 refinement constraint\n(Optional) Classify empty leaves via signed-distance tests\n\nReturns\n\nTriangleOctree{M,C,T} ready for fast spatial queries (T defaults to Float64)\n\nExample\n\nmesh = GeoIO.load(\"box.stl\").geometry\noctree = TriangleOctree(mesh; h_min=0.01, max_triangles_per_box=50)\nprintln(\"Built octree with \", num_leaves(octree), \" leaves\")\n\n\n\n\n\n","category":"method"},{"location":"api/#Meshes.boundingbox-Union{Tuple{AbstractVector{<:Point{M, C}}}, Tuple{C}, Tuple{M}} where {M, C}","page":"API","title":"Meshes.boundingbox","text":"boundingbox(pts::AbstractVector{<:Point})\n\nCompute the axis-aligned bounding box of a collection of points.\n\n\n\n\n\n","category":"method"},{"location":"api/#Meshes.centroid-Union{Tuple{AbstractVector{<:Point{M, C}}}, Tuple{C}, Tuple{M}} where {M, C}","page":"API","title":"Meshes.centroid","text":"centroid(pts::AbstractVector{<:Point})\n\nCompute the centroid (geometric center) of a collection of points.\n\n\n\n\n\n","category":"method"},{"location":"api/#Meshes.discretize-Tuple{PointBoundary{Meshes.ð”¼{3}}, AbstractSpacing}","page":"API","title":"Meshes.discretize","text":"discretize(bnd::PointBoundary, spacing; alg=auto, max_points=10_000_000)\n\nGenerate volume points for the given boundary and return a new PointCloud.\n\nspacing can be either an AbstractSpacing object or a bare Unitful.Length value (which will be wrapped in ConstantSpacing).\n\nKeyword Arguments\n\nalg: Discretization algorithm (default: SlakKosec() for 3D)\nmax_points: Maximum number of volume points to generate\n\nExample\n\nmesh = GeoIO.load(\"model.stl\").geometry\nboundary = PointBoundary(mesh)\noctree = TriangleOctree(mesh; h_min=0.1)\ncloud = discretize(boundary, 3.0m; alg=SlakKosec(octree), max_points=100_000)\n\n\n\n\n\n","category":"method"},{"location":"api/#Meshes.discretize-Tuple{PointBoundary{Meshes.ð”¼{3}}, OctreeRandom}","page":"API","title":"Meshes.discretize","text":"discretize(bnd::PointBoundary{ð”¼{3}}, alg::OctreeRandom; max_points=10_000_000)\n\nGenerate volume points using OctreeRandom without requiring a spacing parameter.\n\nOctreeRandom generates uniformly random points and does not use spacing, so this overload removes the need for a dummy spacing value.\n\nExample\n\nmesh = GeoIO.load(\"bunny.stl\").geometry\nboundary = PointBoundary(mesh)\ncloud = discretize(boundary, OctreeRandom(mesh); max_points=100_000)\n\n\n\n\n\n","category":"method"},{"location":"api/#Meshes.discretize-Tuple{PointCloud, AbstractSpacing}","page":"API","title":"Meshes.discretize","text":"discretize(cloud::PointCloud, spacing; alg=auto, max_points=10_000_000)\n\nGenerate volume points for an existing cloud and return a new PointCloud with the volume populated.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.compute_normals-Union{Tuple{C}, Tuple{N}, Tuple{KNearestSearch, PointSurface{Meshes.ð”¼{N}, C}}} where {N, C<:CoordRefSystems.CRS}","page":"API","title":"WhatsThePoint.compute_normals","text":"compute_normals(search_method::KNearestSearch, surf::PointSurface{ð”¼{N},C}) where {N,C<:CRS}\n\nEstimate the normals of a set of points that form a surface. Uses the PCA approach from \"Surface Reconstruction from Unorganized Points\" - Hoppe (1992).\n\nRequires Euclidean manifold (ð”¼{2} or ð”¼{3}). This function assumes flat space geometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.compute_normals-Union{Tuple{PointSurface{Meshes.ð”¼{N}, C}}, Tuple{C}, Tuple{N}} where {N, C<:CoordRefSystems.CRS}","page":"API","title":"WhatsThePoint.compute_normals","text":"compute_normals(surf::PointSurface{ð”¼{N},C}; k::Int=5) where {N,C<:CRS}\n\nEstimate the normals of a set of points that form a surface. Uses the PCA approach from \"Surface Reconstruction from Unorganized Points\" - Hoppe (1992).\n\nRequires Euclidean manifold (ð”¼{2} or ð”¼{3}). This function assumes flat space geometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.emptyspace-Union{Tuple{P}, Tuple{P, Vector{P}, Union{Unitful.Quantity{T, ð‹, U}, Unitful.Level{L, S, Unitful.Quantity{T, ð‹, U}} where {L, S}} where {T, U}}} where P<:Point","page":"API","title":"WhatsThePoint.emptyspace","text":"emptyspace(testpoint, points)\n\nCheck if a point occupies empty space within a certain tolerance.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.has_consistent_normals-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh}} where T","page":"API","title":"WhatsThePoint.has_consistent_normals","text":"has_consistent_normals(mesh::SimpleMesh) -> Bool\n\nCheck if triangle faces are consistently oriented (manifold orientation test).\n\nThis function verifies that all shared edges between adjacent triangles are traversed in OPPOSITE directions, which is the geometric requirement for a properly oriented manifold surface. This test is independent of surface curvature.\n\nAlgorithm\n\nFor each shared edge between two triangles:\n\nTriangle A has edge v1â†’v2\nTriangle B (adjacent) must have edge v2â†’v1 (opposite direction)\nIf both traverse in the same direction â†’ faces are incorrectly oriented\n\nReturns\n\ntrue if all triangles are correctly oriented (manifold surface)\nfalse if any triangles have flipped faces (orientation errors)\n\nPerformance\n\nO(n) complexity using edge hash map instead of O(nÂ²) pairwise comparison.\n\nExamples\n\noctree = TriangleOctree(\"model.stl\"; h_min=0.01)\nif !has_consistent_normals(octree.mesh)\n    @warn \"Mesh has flipped triangles - will cause incorrect isinside() results\"\nend\n\nNote\n\nThis test uses GEOMETRIC edge orientation, not algebraic normal dot products. It will correctly validate meshes with high curvature (sharp edges, creases).\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.hastopology-Tuple{PointCloud}","page":"API","title":"WhatsThePoint.hastopology","text":"hastopology(cloud::PointCloud)\n\nCheck if point cloud has a topology (not NoTopology).\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.hastopology-Tuple{PointSurface}","page":"API","title":"WhatsThePoint.hastopology","text":"hastopology(surf::PointSurface)\n\nCheck if surface has a topology (not NoTopology).\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.hastopology-Tuple{PointVolume}","page":"API","title":"WhatsThePoint.hastopology","text":"hastopology(vol::PointVolume)\n\nCheck if volume has a topology (not NoTopology).\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.isinside-Tuple{AbstractVector{<:Point{Meshes.ð”¼{3}}}, TriangleOctree{Meshes.ð”¼{3}}}","page":"API","title":"WhatsThePoint.isinside","text":"isinside(points::AbstractVector{<:Point{ð”¼{3}}}, octree::TriangleOctree{ð”¼{3}}) -> Vector{Bool}\n\nBatch bridge from Meshes.jl Points to SVector-based isinside.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.isinside-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, TriangleOctree}} where T<:Real","page":"API","title":"WhatsThePoint.isinside","text":"isinside(points::Vector{SVector{3,T}}, octree::TriangleOctree) -> Vector{Bool}\n\nBatch interior test for multiple points.\n\nExample\n\ntest_points = [SVector(randn(3)...) for _ in 1:1000]\nresults = isinside(test_points, octree)  # Returns Vector{Bool}\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.isinside-Union{Tuple{T}, Tuple{C}, Tuple{Point{Meshes.ð”¼{3}}, TriangleOctree{Meshes.ð”¼{3}, C, T}}} where {C, T}","page":"API","title":"WhatsThePoint.isinside","text":"isinside(point::Point{ð”¼{3}}, octree::TriangleOctree{ð”¼{3},C,T}) -> Bool\n\nBridge from Meshes.jl Point to SVector-based isinside.\n\nExtracts coordinates from Point, converts to SVector{3,T}, and delegates to the SVector method.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.isinside-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, TriangleOctree}} where T<:Real","page":"API","title":"WhatsThePoint.isinside","text":"isinside(point::SVector{3,T}, octree::TriangleOctree) -> Bool\n\nFast interior/exterior test using octree spatial index.\n\nReturns true if point is inside the closed surface defined by the mesh.\n\nPerformance\n\nComplexity: O(log M + k) where M = number of triangles, k â‰ˆ 10-50\nSpeedup: 100-1000Ã— faster than brute-force O(M) approach\n\nExample\n\nusing WhatsThePoint, StaticArrays\n\noctree = TriangleOctree(\"model.stl\"; h_min=0.01, classify_leaves=true)\n\npoint = SVector(0.5, 0.5, 0.5)\nis_inside = isinside(point, octree)\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.neighbors-Tuple{AbstractTopology, Int64}","page":"API","title":"WhatsThePoint.neighbors","text":"neighbors(t::AbstractTopology, i::Int)\n\nReturn neighbors of point i.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.neighbors-Tuple{AbstractTopology}","page":"API","title":"WhatsThePoint.neighbors","text":"neighbors(t::AbstractTopology)\n\nReturn the neighbor storage from a topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.neighbors-Tuple{PointCloud, Int64}","page":"API","title":"WhatsThePoint.neighbors","text":"neighbors(cloud::PointCloud, i::Int)\n\nReturn neighbors of point i. Throws error if no topology or invalid.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.neighbors-Tuple{PointCloud}","page":"API","title":"WhatsThePoint.neighbors","text":"neighbors(cloud::PointCloud)\n\nReturn all neighbor lists from the topology. Throws error if no topology or invalid.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.neighbors-Tuple{PointSurface, Int64}","page":"API","title":"WhatsThePoint.neighbors","text":"neighbors(surf::PointSurface, i::Int)\n\nReturn neighbors of point i in surface-local indices. Throws error if no topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.neighbors-Tuple{PointSurface}","page":"API","title":"WhatsThePoint.neighbors","text":"neighbors(surf::PointSurface)\n\nReturn all neighbor lists from the surface topology. Throws error if no topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.neighbors-Tuple{PointVolume, Int64}","page":"API","title":"WhatsThePoint.neighbors","text":"neighbors(vol::PointVolume, i::Int)\n\nReturn neighbors of point i in volume-local indices. Throws error if no topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.neighbors-Tuple{PointVolume}","page":"API","title":"WhatsThePoint.neighbors","text":"neighbors(vol::PointVolume)\n\nReturn all neighbor lists from the volume topology. Throws error if no topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.orient_normals!-Tuple{KNearestSearch, AbstractVector{<:AbstractVector}, Any}","page":"API","title":"WhatsThePoint.orient_normals!","text":"orient_normals!(search_method::KNearestSearch, normals::AbstractVector{<:AbstractVector}, points)\n\nCorrect the orientation of normals on a surface as the compute_normals function does not guarantee if the normal is inward or outward facing. Uses the approach from \"Surface Reconstruction from Unorganized Points\" - Hoppe (1992).\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.orient_normals!-Union{Tuple{N}, Tuple{AbstractVector{<:AbstractVector}, AbstractVector{<:Point{Meshes.ð”¼{N}}}}} where N","page":"API","title":"WhatsThePoint.orient_normals!","text":"orient_normals!(normals::AbstractVector{<:AbstractVector}, points::AbstractVector{<:Point{ð”¼{N}}}; k::Int=5) where {N}\n\nCorrect the orientation of normals on a surface as the compute_normals function does not guarantee if the normal is inward or outward facing. Uses the approach from \"Surface Reconstruction from Unorganized Points\" - Hoppe (1992).\n\nRequires Euclidean manifold (ð”¼{2} or ð”¼{3}). This function uses Euclidean dot products for orientation consistency.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.points-Tuple{PointBoundary}","page":"API","title":"WhatsThePoint.points","text":"points(boundary::PointBoundary)\n\nReturn vector of all points from all surfaces in the boundary.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.points-Tuple{PointCloud}","page":"API","title":"WhatsThePoint.points","text":"points(cloud::PointCloud)\n\nReturn vector of all points (boundary + volume).\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.points-Tuple{PointSurface}","page":"API","title":"WhatsThePoint.points","text":"points(surf::PointSurface)\n\nReturn vector of points from surface. Alias for point(surf).\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.points-Tuple{PointVolume}","page":"API","title":"WhatsThePoint.points","text":"points(vol::PointVolume)\n\nReturn vector of points from volume.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.rebuild_topology!-Tuple{KNNTopology, Any}","page":"API","title":"WhatsThePoint.rebuild_topology!","text":"rebuild_topology!(topo::KNNTopology, points)\n\nRebuild k-nearest neighbor topology in place.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.rebuild_topology!-Tuple{NoTopology, Any}","page":"API","title":"WhatsThePoint.rebuild_topology!","text":"rebuild_topology!(topo::NoTopology, points)\n\nNo-op for NoTopology (nothing to rebuild).\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.rebuild_topology!-Tuple{PointCloud}","page":"API","title":"WhatsThePoint.rebuild_topology!","text":"rebuild_topology!(cloud::PointCloud)\n\nRebuild topology in place using same parameters. No-op if NoTopology.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.rebuild_topology!-Tuple{PointSurface}","page":"API","title":"WhatsThePoint.rebuild_topology!","text":"rebuild_topology!(surf::PointSurface)\n\nRebuild topology in place using same parameters. No-op if NoTopology.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.rebuild_topology!-Tuple{PointVolume}","page":"API","title":"WhatsThePoint.rebuild_topology!","text":"rebuild_topology!(vol::PointVolume)\n\nRebuild topology in place using same parameters. No-op if NoTopology.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.rebuild_topology!-Tuple{RadiusTopology, Any}","page":"API","title":"WhatsThePoint.rebuild_topology!","text":"rebuild_topology!(topo::RadiusTopology, points)\n\nRebuild radius-based topology in place.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.repel-Union{Tuple{C}, Tuple{N}, Tuple{PointCloud{Meshes.ð”¼{N}, C}, Any}} where {N, C<:CoordRefSystems.CRS}","page":"API","title":"WhatsThePoint.repel","text":"repel(cloud::PointCloud, spacing; Î²=0.2, Î±=auto, k=21, max_iters=1000, tol=1e-6)\n\nOptimize point distribution via node repulsion (Miotti 2023). Returns (new_cloud, convergence_vector) tuple.\n\nThe returned cloud has NoTopology since points have moved.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.set_topology-Tuple{PointCloud, Type{KNNTopology}, Int64}","page":"API","title":"WhatsThePoint.set_topology","text":"set_topology(cloud::PointCloud, ::Type{KNNTopology}, k::Int)\n\nBuild and return new cloud with k-nearest neighbor topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.set_topology-Tuple{PointCloud, Type{RadiusTopology}, Any}","page":"API","title":"WhatsThePoint.set_topology","text":"set_topology(cloud::PointCloud, ::Type{RadiusTopology}, radius)\n\nBuild and return new cloud with radius-based topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.set_topology-Tuple{PointSurface, Type{KNNTopology}, Int64}","page":"API","title":"WhatsThePoint.set_topology","text":"set_topology(surf::PointSurface, ::Type{KNNTopology}, k::Int)\n\nBuild and return new surface with k-nearest neighbor topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.set_topology-Tuple{PointSurface, Type{RadiusTopology}, Any}","page":"API","title":"WhatsThePoint.set_topology","text":"set_topology(surf::PointSurface, ::Type{RadiusTopology}, radius)\n\nBuild and return new surface with radius-based topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.set_topology-Tuple{PointVolume, Type{KNNTopology}, Int64}","page":"API","title":"WhatsThePoint.set_topology","text":"set_topology(vol::PointVolume, ::Type{KNNTopology}, k::Int)\n\nBuild and return new volume with k-nearest neighbor topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.set_topology-Tuple{PointVolume, Type{RadiusTopology}, Any}","page":"API","title":"WhatsThePoint.set_topology","text":"set_topology(vol::PointVolume, ::Type{RadiusTopology}, radius)\n\nBuild and return new volume with radius-based topology.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.topology-Tuple{PointCloud}","page":"API","title":"WhatsThePoint.topology","text":"topology(cloud::PointCloud)\n\nReturn the topology of the point cloud.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.topology-Tuple{PointSurface}","page":"API","title":"WhatsThePoint.topology","text":"topology(surf::PointSurface)\n\nReturn the topology of the surface.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.topology-Tuple{PointVolume}","page":"API","title":"WhatsThePoint.topology","text":"topology(vol::PointVolume)\n\nReturn the topology of the volume.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.update_normals!-Union{Tuple{PointSurface{Meshes.ð”¼{N}, C}}, Tuple{C}, Tuple{N}} where {N, C<:CoordRefSystems.CRS}","page":"API","title":"WhatsThePoint.update_normals!","text":"update_normals!(surf::PointSurface{ð”¼{N},C}; k::Int=5) where {N,C<:CRS}\n\nUpdate the normals of the boundary of a surf. This is necessary whenever the points change for any reason.\n\nRequires Euclidean manifold (ð”¼{2} or ð”¼{3}). This function assumes flat space geometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.AbstractOctree","page":"API","title":"WhatsThePoint.AbstractOctree","text":"AbstractOctree{E,T} = AbstractSpatialTree{3,E,T}\n\nConvenience alias for 3D spatial trees (octrees).\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.AbstractSpatialTree","page":"API","title":"WhatsThePoint.AbstractSpatialTree","text":"AbstractSpatialTree{N,E,T}\n\nAbstract type for N-dimensional spatial trees.\n\nType Parameters\n\nN::Int: Spatial dimensionality (2 for quadtree, 3 for octree)\nE: Element type stored in tree (e.g., Int for indices)\nT<:Real: Coordinate numeric type (Float64, Float32, etc.)\n\nInterface Requirements\n\nTrees must implement:\n\nfind_leaf(tree, point) - Locate leaf containing point\nbounding_box(tree) - Get overall bounds\nnum_elements(tree) - Total elements stored\n\nOptional:\n\nfind_neighbors(tree, box_idx, direction) - Neighbor queries\nbalance!(tree) - Enforce refinement constraints\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.AndCriterion","page":"API","title":"WhatsThePoint.AndCriterion","text":"AndCriterion{T<:Tuple} <: SubdivisionCriterion\n\nCombine multiple criteria - all must be satisfied for subdivision.\n\nFields\n\ncriteria::T: Tuple of criteria to combine (parametrized for type stability)\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.MaxElementsCriterion","page":"API","title":"WhatsThePoint.MaxElementsCriterion","text":"MaxElementsCriterion <: SubdivisionCriterion\n\nSubdivide box if number of elements exceeds threshold.\n\nFields\n\nmax_elements::Int: Maximum elements before subdivision\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.NearestTriangleState","page":"API","title":"WhatsThePoint.NearestTriangleState","text":"NearestTriangleState{T<:Real}\n\nMutable state for nearest-triangle search, replacing 3 separate Ref allocations with a single struct (1 heap allocation instead of 3, enables potential SROA).\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.SizeCriterion","page":"API","title":"WhatsThePoint.SizeCriterion","text":"SizeCriterion{T<:Real} <: SubdivisionCriterion\n\nSubdivide box if size exceeds threshold.\n\nFields\n\nh_min::T: Minimum box size (stop subdividing when reached)\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.SpatialOctree","page":"API","title":"WhatsThePoint.SpatialOctree","text":"SpatialOctree{E,T<:Real} <: AbstractOctree{E,T}\n\nConcrete octree implementation using integer coordinate system for efficient neighbor finding.\n\nUses (i,j,k,N) coordinate system where:\n\n(i,j,k) are integer coordinates at refinement level N\nBox center = origin + (2*[i,j,k] + 1) * (root_size / N) / 2\nEnables O(1) neighbor calculation from coordinates\n\nType Parameters\n\nE: Type of elements stored (e.g., Int for triangle IDs)\nT: Coordinate numeric type (e.g., Float64, Float32)\n\nFields\n\nparent::Vector{Int}: Parent box index for each node (0 = root has no parent)\nchildren::Vector{SVector{8,Int}}: 8 child indices per box (0 = no child)\ncoords::Vector{SVector{4,Int}}: (i,j,k,N) coordinates per box where N is refinement level\norigin::SVector{3,T}: Spatial origin of root box\nroot_size::T: Size of root box (assumed cubic)\nelement_lists::Vector{Vector{E}}: Elements in each box\nnum_boxes::Ref{Int}: Current number of boxes (mutable counter)\n\nInterface Implementation\n\nImplements AbstractSpatialTree interface:\n\nfind_leaf(tree, point) - O(log n) point location\nbounding_box(tree) - Root box bounds\nnum_elements(tree) - Total stored elements\nfind_neighbor(tree, box, dir) - 6-directional neighbor finding\nbalance_octree!(tree) - 2:1 refinement constraint\n\nExample\n\nusing StaticArrays\n\norigin = SVector(0.0, 0.0, 0.0)\noctree = SpatialOctree{Int,Float64}(origin, 10.0)\n\n# Subdivide root\nsubdivide!(octree, 1)\n\n# Find leaf containing point\npoint = SVector(2.0, 2.0, 2.0)\nleaf = find_leaf(octree, point)\n\n\n\n\n\n","category":"type"},{"location":"api/#WhatsThePoint.SpatialOctree-Union{Tuple{T}, Tuple{E}, Tuple{StaticArraysCore.SVector{3, T}, T}} where {E, T}","page":"API","title":"WhatsThePoint.SpatialOctree","text":"SpatialOctree{E,T}(origin::SVector{3,T}, size::T; initial_capacity=1000)\n\nCreate empty octree with root node.\n\nArguments\n\norigin: Minimum corner of root box\nsize: Edge length of root box (assumed cubic)\ninitial_capacity: Initial array capacity (will grow as needed)\n\nExample\n\norigin = SVector(0.0, 0.0, 0.0)\noctree = SpatialOctree{Int,Float64}(origin, 10.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.SubdivisionCriterion","page":"API","title":"WhatsThePoint.SubdivisionCriterion","text":"SubdivisionCriterion\n\nAbstract type for subdivision decision logic.\n\nAllows pluggable subdivision criteria via dispatch.\n\nBuilt-in Criteria\n\nMaxElementsCriterion(max_elements) - Subdivide if too many elements\nSizeCriterion(h_min) - Subdivide until box small enough\nAndCriterion(criteria...) - All criteria must be satisfied\n\nExample\n\ncriterion = AndCriterion((\n    MaxElementsCriterion(50),\n    SizeCriterion(0.1)\n))\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.filter-Tuple{Function, PointVolume}","page":"API","title":"Base.filter","text":"filter(f::Function, vol::PointVolume)\n\nReturn new PointVolume with only points satisfying predicate f. Topology is stripped since point indices change.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isvalid-Tuple{Union{KNNTopology, RadiusTopology}}","page":"API","title":"Base.isvalid","text":"isvalid(t::AbstractTopology)\n\nCheck if topology is valid. With immutable design, topology is always valid if it exists.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._allocate_counts_by_volume-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T<:Real","page":"API","title":"WhatsThePoint._allocate_counts_by_volume","text":"_allocate_counts_by_volume(volumes, total_count; ensure_one=false)\n\nAllocate integer counts across leaves proportionally to volumes using largest-remainder rounding, preserving exact total count.\n\nIf ensure_one=true and total_count >= length(volumes), each leaf gets at least one allocation before distributing the remainder by volume.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._auto_h_min-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh}} where T","page":"API","title":"WhatsThePoint._auto_h_min","text":"_auto_h_min(::Type{T}, mesh::SimpleMesh) where {T}\n\nCompute a default h_min for octree construction based on mesh geometry.\n\nHeuristic: bbox_diagonal / (2 * cbrt(n_triangles)). Scales leaf size to the mesh's characteristic triangle spacing so the octree resolves surface detail without excessive subdivision.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._build_knn_neighbors-Tuple{Any, Int64}","page":"API","title":"WhatsThePoint._build_knn_neighbors","text":"_build_knn_neighbors(points, k::Int) -> Vector{Vector{Int}}\n\nBuild k-nearest neighbor adjacency list from points.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._build_radius_neighbors-Tuple{Any, Any}","page":"API","title":"WhatsThePoint._build_radius_neighbors","text":"_build_radius_neighbors(points, radius) -> Vector{Vector{Int}}\n\nBuild radius-based adjacency list from points.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._classify_empty_leaf_conservative-Union{Tuple{T}, Tuple{WhatsThePoint.SpatialOctree{Int64, T}, Meshes.SimpleMesh, Int64}} where T<:Real","page":"API","title":"WhatsThePoint._classify_empty_leaf_conservative","text":"_classify_empty_leaf_conservative(tree, mesh, leaf_idx) -> Int8\n\nConservative classification for empty leaves.\n\n2 (interior): center and all 8 corners classify inside\n0 (exterior): center and all 8 corners classify outside\n1 (boundary): mixed results\n\nThis avoids falsely labeling a partially-outside leaf as interior.\n\nImplementation uses octree-accelerated signed distance, not ray casting.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._classify_leaves-Union{Tuple{T}, Tuple{WhatsThePoint.SpatialOctree{Int64, T}, Meshes.SimpleMesh}} where T<:Real","page":"API","title":"WhatsThePoint._classify_leaves","text":"_classify_leaves(tree::SpatialOctree{Int,T}, mesh::SimpleMesh) -> Vector{Int8}\n\nClassify octree leaves as exterior (0), boundary (1), or interior (2).\n\nUses octree-accelerated signed distance for robust classification.\n\nReturns\n\nclassification::Vector{Int8}: Classification for each box\n-1: Internal node (not a leaf, unclassified)\n0: Exterior leaf\n1: Boundary leaf\n2: Interior leaf\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._collect_classified_leaves-Tuple{TriangleOctree}","page":"API","title":"WhatsThePoint._collect_classified_leaves","text":"_collect_classified_leaves(octree::TriangleOctree)\n\nCollect interior and boundary leaves with their volumes from a classified octree.\n\nReturns (interior_leaves, interior_volumes, boundary_leaves, boundary_volumes).\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._compute_bbox-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh}} where T","page":"API","title":"WhatsThePoint._compute_bbox","text":"_compute_bbox(::Type{T}, mesh::SimpleMesh) where {T} -> (bbox_min, bbox_max)\n\nCompute bounding box from mesh triangle data.\n\nPerformance: Single-pass min/max accumulation over all triangles.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._compute_local_signed_distance-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, Meshes.SimpleMesh, Vector{Int64}}} where T<:Real","page":"API","title":"WhatsThePoint._compute_local_signed_distance","text":"_compute_local_signed_distance(\n    point::SVector{3,T},\n    mesh::SimpleMesh,\n    tri_indices::Vector{Int}\n) -> T\n\nCompute signed distance from point to nearest triangle in the local set.\n\nThis is the key performance optimization: instead of checking all M triangles, we only check the kâ‰ˆ10-50 triangles in the point's octree leaf.\n\nPerformance: Fused computation avoids redundant closest_point calculation.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._compute_signed_distance_octree-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, Meshes.SimpleMesh, WhatsThePoint.SpatialOctree{Int64, T}}} where T<:Real","page":"API","title":"WhatsThePoint._compute_signed_distance_octree","text":"_compute_signed_distance_octree(point, mesh, tree) -> T\n\nCompute signed distance to the closest triangle using octree branch-and-bound.\n\nThis avoids global O(M) triangle scans by searching only relevant octree regions.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._create_root_octree-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh, Int64}} where T","page":"API","title":"WhatsThePoint._create_root_octree","text":"_create_root_octree(::Type{T}, mesh::SimpleMesh, n_triangles::Int) where {T} -> SpatialOctree{Int,T}\n\nCreate root octree covering mesh bounding box with all triangles in root.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._edge_key-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T","page":"API","title":"WhatsThePoint._edge_key","text":"_edge_key(v1::SVector{3,T}, v2::SVector{3,T}) where {T} -> Tuple\n\nCreate a canonical edge key from two vertices (order-independent). Uses component-wise comparison for consistent ordering.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._extract_vertex-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"API","title":"WhatsThePoint._extract_vertex","text":"_extract_vertex(::Type{T}, vert) where {T} -> SVector{3,T}\n\nExtract coordinates from a Meshes.jl vertex to an SVector{3,T}.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._get_triangle_normal-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh, Int64}} where T","page":"API","title":"WhatsThePoint._get_triangle_normal","text":"_get_triangle_normal(::Type{T}, mesh::SimpleMesh, tri_idx::Int) where {T} -> SVector{3,T}\n\nExtract and normalize triangle normal from mesh. Accesses mesh data on-the-fly.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._get_triangle_vertices-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh, Int64}} where T","page":"API","title":"WhatsThePoint._get_triangle_vertices","text":"_get_triangle_vertices(::Type{T}, mesh::SimpleMesh, tri_idx::Int) where {T} -> (SVector{3,T}, SVector{3,T}, SVector{3,T})\n\nExtract triangle vertices from mesh as SVectors. Accesses mesh data on-the-fly.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._normalize_normal-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"API","title":"WhatsThePoint._normalize_normal","text":"_normalize_normal(::Type{T}, n_vec) where {T} -> SVector{3,T}\n\nExtract and normalize a Meshes.jl Vec normal to a unit SVector{3,T}.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._subdivide_triangle_octree!-Union{Tuple{T}, Tuple{WhatsThePoint.SpatialOctree{Int64, T}, Meshes.SimpleMesh, Int64, WhatsThePoint.SubdivisionCriterion}} where T<:Real","page":"API","title":"WhatsThePoint._subdivide_triangle_octree!","text":"_subdivide_triangle_octree!(tree, mesh, box_idx, criterion)\n\nRecursively subdivide a box in the triangle octree.\n\nFor each box that needs subdivision:\n\nCreate 8 child boxes\nFor each triangle in parent, find which children it intersects\nDistribute triangle indices to children\nRecursively subdivide children if they meet criteria\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint._triangle_axis_test-Union{Tuple{T}, NTuple{5, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"API","title":"WhatsThePoint._triangle_axis_test","text":"_triangle_axis_test(\n    axis::SVector{3,T},\n    v0::SVector{3,T},\n    v1::SVector{3,T},\n    v2::SVector{3,T},\n    half::SVector{3,T}\n) where {T<:Real} -> Bool\n\nInternal helper for triangle-box intersection separating axis test.\n\nTests if the projection intervals of the triangle vertices and box overlap along the given axis.\n\nArguments\n\naxis: Separating axis direction\nv0, v1, v2: Triangle vertices in box-centered coordinates\nhalf: Box half-extents\n\nReturns\n\ntrue if intervals overlap (potential intersection), false if separated\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.add_box!-Union{Tuple{E}, Tuple{WhatsThePoint.SpatialOctree{E}, Vararg{Int64, 5}}} where E","page":"API","title":"WhatsThePoint.add_box!","text":"add_box!(octree::SpatialOctree, i::Int, j::Int, k::Int, N::Int, parent_idx::Int) -> Int\n\nAdd new box to octree. Returns box index.\n\nAutomatically grows arrays if capacity exceeded.\n\nArguments\n\ni, j, k: Integer coordinates at level N\nN: Refinement level (N=1 is root, N=2 is first subdivision, etc.)\nparent_idx: Index of parent box\n\nReturns\n\nIndex of newly created box\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.all_boxes-Tuple{WhatsThePoint.SpatialOctree}","page":"API","title":"WhatsThePoint.all_boxes","text":"all_boxes(octree::SpatialOctree) -> Vector{Int}\n\nReturn indices of all boxes (leaves and internal nodes).\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.all_leaves-Tuple{WhatsThePoint.SpatialOctree}","page":"API","title":"WhatsThePoint.all_leaves","text":"all_leaves(octree::SpatialOctree) -> Vector{Int}\n\nReturn indices of all leaf boxes.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.balance_octree!-Tuple{WhatsThePoint.SpatialOctree, WhatsThePoint.SubdivisionCriterion}","page":"API","title":"WhatsThePoint.balance_octree!","text":"balance_octree!(octree::SpatialOctree, criterion::SubdivisionCriterion)\n\nEnforce 2:1 balance constraint across entire octree.\n\nIteratively subdivides boxes that violate the 2:1 constraint until all adjacent boxes differ by at most one refinement level.\n\nArguments\n\ncriterion: Subdivision criterion (only size constraints are enforced)\n\nAlgorithm\n\nCollect all leaves\nCheck each leaf for balance violations\nSubdivide violating neighbors (only respecting physical limits like h_min)\nRepeat until no violations\n\nNote\n\nUses can_subdivide (not should_subdivide) to ignore element count criteria\nBalancing is a geometric constraint, not an optimization decision\nMaximum iterations limit prevents infinite loops. If hit, tree may not be fully balanced.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.bounding_box-Union{Tuple{WhatsThePoint.SpatialOctree{E, T}}, Tuple{T}, Tuple{E}} where {E, T}","page":"API","title":"WhatsThePoint.bounding_box","text":"bounding_box(octree::SpatialOctree) -> (SVector{3}, SVector{3})\n\nGet overall bounding box of tree (root box).\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.box_bounds-Union{Tuple{T}, Tuple{E}, Tuple{WhatsThePoint.SpatialOctree{E, T}, Int64}} where {E, T}","page":"API","title":"WhatsThePoint.box_bounds","text":"box_bounds(octree::SpatialOctree, box_idx::Int) -> (SVector{3}, SVector{3})\n\nGet (mincorner, maxcorner) of box.\n\nReturns\n\nTuple of (mincorner, maxcorner) as SVector{3,C}\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.box_center-Union{Tuple{T}, Tuple{E}, Tuple{WhatsThePoint.SpatialOctree{E, T}, Int64}} where {E, T}","page":"API","title":"WhatsThePoint.box_center","text":"box_center(octree::SpatialOctree, box_idx::Int) -> SVector{3}\n\nCompute spatial center of box using (i,j,k,N) coordinates.\n\nFormula\n\ncenter = origin + (2*[i,j,k] + 1) * box_size / 2\n\nwhere box_size = root_size / N\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.box_size","page":"API","title":"WhatsThePoint.box_size","text":"box_size(tree::AbstractSpatialTree, box_idx::Int) -> Real\n\nGet edge length of box.\n\nRequired\n\nTrees must implement this function.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.box_size-Tuple{WhatsThePoint.SpatialOctree, Int64}","page":"API","title":"WhatsThePoint.box_size","text":"box_size(octree::SpatialOctree, box_idx::Int) -> Real\n\nGet edge length of box.\n\nBox size at refinement level N is: root_size / N\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.can_subdivide","page":"API","title":"WhatsThePoint.can_subdivide","text":"can_subdivide(criterion::SubdivisionCriterion, tree, box_idx) -> Bool\n\nCheck if box CAN be subdivided based on physical constraints only.\n\nUnlike should_subdivide, this ignores content-based criteria (like element count) and only checks physical limits (like minimum size). Used during balancing where subdivision is required for geometric correctness, not optimization.\n\nArguments\n\ncriterion: Subdivision criterion (only size constraints are checked)\ntree: Spatial tree\nbox_idx: Index of box to check\n\nReturns\n\ntrue if box can physically be subdivided, false if at minimum size limit.\n\nExample\n\n# For balancing, we only respect size limits\nif needs_balancing(leaf)\n    if can_subdivide(criterion, tree, leaf)\n        subdivide!(tree, leaf)\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.closest_point_on_triangle-Union{Tuple{T}, NTuple{4, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"API","title":"WhatsThePoint.closest_point_on_triangle","text":"closest_point_on_triangle(\n    P::SVector{3,T},\n    v1::SVector{3,T},\n    v2::SVector{3,T},\n    v3::SVector{3,T}\n) where {T<:Real} -> SVector{3,T}\n\nCompute the closest point on triangle (v1, v2, v3) to point P.\n\nUses barycentric coordinate method from Ericson's \"Real-Time Collision Detection\". The closest point is computed by:\n\nProjecting P onto the triangle plane\nComputing barycentric coordinates\nClamping to triangle if outside\n\nAlgorithm\n\nThe triangle can be parameterized as:     T(u,v) = v1 + u(v2-v1) + v(v3-v1)  for u,v â‰¥ 0, u+v â‰¤ 1\n\nWe find the closest point by solving a constrained minimization problem.\n\nReturns\n\nPoint on triangle surface closest to P (may be on edge or vertex).\n\nReferences\n\nEricson, \"Real-Time Collision Detection\", Chapter 5.1.5\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.distance_point_triangle-Union{Tuple{T}, NTuple{4, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"API","title":"WhatsThePoint.distance_point_triangle","text":"distance_point_triangle(\n    P::SVector{3,T},\n    v1::SVector{3,T},\n    v2::SVector{3,T},\n    v3::SVector{3,T}\n) where {T<:Real} -> T\n\nCompute unsigned distance from point P to triangle (v1, v2, v3).\n\nReturns\n\nUnsigned distance (always positive or zero)\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.distance_point_triangle-Union{Tuple{T}, NTuple{5, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"API","title":"WhatsThePoint.distance_point_triangle","text":"distance_point_triangle(\n    P::SVector{3,T},\n    v1::SVector{3,T},\n    v2::SVector{3,T},\n    v3::SVector{3,T},\n    normal::SVector{3,T}\n) where {T<:Real} -> T\n\nCompute signed distance from point P to triangle (v1, v2, v3).\n\nThe distance is:\n\nPositive if P is on the side of the triangle that the normal points to\nNegative if P is on the opposite side\nZero if P is on the triangle plane\n\nAlgorithm\n\nFind closest point Q on triangle to P\nCompute distance ||P - Q||\nDetermine sign based on which side of triangle P is on\n\nArguments\n\nP: Query point\nv1, v2, v3: Triangle vertices in counterclockwise order\nnormal: Outward-pointing unit normal vector\n\nReturns\n\nSigned distance (positive = outside, negative = inside for closed surface)\n\nExample\n\nusing StaticArrays\n\n# Triangle in xy-plane\nv1 = SVector(0.0, 0.0, 0.0)\nv2 = SVector(1.0, 0.0, 0.0)\nv3 = SVector(0.0, 1.0, 0.0)\nnormal = SVector(0.0, 0.0, 1.0)\n\n# Point above triangle\nP = SVector(0.25, 0.25, 1.0)\nd = distance_point_triangle(P, v1, v2, v3, normal)\n# d â‰ˆ 1.0 (positive, on normal side)\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.find_boxes_at_coords-Tuple{WhatsThePoint.SpatialOctree, Vararg{Int64, 4}}","page":"API","title":"WhatsThePoint.find_boxes_at_coords","text":"find_boxes_at_coords(octree::SpatialOctree, i_target::Int, j_target::Int, k_target::Int, N_target::Int) -> Vector{Int}\n\nFind box(es) at given (i,j,k,N) coordinates.\n\nIf exact match found at level Ntarget, returns [boxidx]\nIf location is covered by coarser box, returns [coarserboxidx]\nIf location is subdivided finer, returns all descendants at that location\n\nReturns\n\nVector of box indices covering the target location\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.find_leaf-Union{Tuple{T}, Tuple{E}, Tuple{WhatsThePoint.SpatialOctree{E, T}, StaticArraysCore.SVector{3, T}}} where {E, T}","page":"API","title":"WhatsThePoint.find_leaf","text":"find_leaf(octree::SpatialOctree, point::SVector{3}) -> Int\n\nFind leaf box containing point. Returns box index.\n\nTraverses tree from root to leaf in O(log n) time.\n\nArguments\n\npoint: Query point in same coordinate system as octree\n\nReturns\n\nIndex of leaf box containing point\n\nThrows\n\nAssertionError if point is outside octree bounds\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.find_neighbor-Tuple{WhatsThePoint.SpatialOctree, Int64, Int64}","page":"API","title":"WhatsThePoint.find_neighbor","text":"find_neighbor(octree::SpatialOctree, box_idx::Int, direction::Int) -> Vector{Int}\n\nFind neighbor(s) in given direction. Returns vector of neighbor indices.\n\nHandles 2:1 refinement level difference:\n\nIf neighbor exists at same level: returns [neighbor_idx]\nIf neighbor is subdivided (finer): returns children on shared face (up to 4)\nIf neighbor doesn't exist (boundary): returns empty vector\n\nArguments\n\nbox_idx: Box to find neighbor of\ndirection: Direction code (1-6, see neighbor_direction)\n\nReturns\n\nVector of neighbor box indices (may be empty if at boundary)\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.has_children","page":"API","title":"WhatsThePoint.has_children","text":"has_children(tree::AbstractSpatialTree, box_idx::Int) -> Bool\n\nCheck if box has been subdivided.\n\nRequired\n\nTrees must implement this function.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.has_children-Tuple{WhatsThePoint.SpatialOctree, Int64}","page":"API","title":"WhatsThePoint.has_children","text":"has_children(octree::SpatialOctree, box_idx::Int) -> Bool\n\nCheck if box has been subdivided.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.is_leaf","page":"API","title":"WhatsThePoint.is_leaf","text":"is_leaf(tree::AbstractSpatialTree, box_idx::Int) -> Bool\n\nCheck if box is a leaf (has no children).\n\nRequired\n\nTrees must implement this function.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.is_leaf-Tuple{WhatsThePoint.SpatialOctree, Int64}","page":"API","title":"WhatsThePoint.is_leaf","text":"is_leaf(octree::SpatialOctree, box_idx::Int) -> Bool\n\nCheck if box has no children.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.needs_balancing-Tuple{WhatsThePoint.SpatialOctree, Int64}","page":"API","title":"WhatsThePoint.needs_balancing","text":"needs_balancing(octree::SpatialOctree, box_idx::Int) -> Bool\n\nCheck if subdividing this box would violate 2:1 balance with any neighbor.\n\nReturns true if any neighbor has grandchildren (2-level refinement difference).\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.neighbor_direction-Tuple{Int64}","page":"API","title":"WhatsThePoint.neighbor_direction","text":"neighbor_direction(direction::Int) -> (Int, Int, Int)\n\nConvert direction code to (di, dj, dk) offset.\n\nDirection Codes\n\n1: -x (left)\n2: +x (right)\n3: -y (bottom)\n4: +y (top)\n5: -z (front)\n6: +z (back)\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.num_elements-Tuple{WhatsThePoint.SpatialOctree}","page":"API","title":"WhatsThePoint.num_elements","text":"num_elements(octree::SpatialOctree) -> Int\n\nTotal number of elements stored in tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.should_subdivide","page":"API","title":"WhatsThePoint.should_subdivide","text":"should_subdivide(criterion::SubdivisionCriterion, tree, box_idx) -> Bool\n\nDetermine if box should be subdivided based on criterion.\n\nArguments\n\ncriterion: Subdivision criterion to evaluate\ntree: Spatial tree\nbox_idx: Index of box to check\n\nReturns\n\ntrue if box should be subdivided, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#WhatsThePoint.subdivide!-Tuple{WhatsThePoint.SpatialOctree, Int64}","page":"API","title":"WhatsThePoint.subdivide!","text":"subdivide!(octree::SpatialOctree, box_idx::Int) -> SVector{8,Int}\n\nSubdivide box into 8 children. Returns child indices [1:8].\n\nChild Ordering (Standard Octree Convention)\n\n1: (0,0,0) - bottom-left-front   (x-, y-, z-) 2: (1,0,0) - bottom-right-front  (x+, y-, z-) 3: (0,1,0) - top-left-front      (x-, y+, z-) 4: (1,1,0) - top-right-front     (x+, y+, z-) 5: (0,0,1) - bottom-left-back    (x-, y-, z+) 6: (1,0,1) - bottom-right-back   (x+, y-, z+) 7: (0,1,1) - top-left-back       (x-, y+, z+) 8: (1,1,1) - top-right-back      (x+, y+, z+)\n\nArguments\n\nbox_idx: Index of box to subdivide (must be leaf)\n\nReturns\n\nSVector{8,Int} of child indices in standard order\n\n\n\n\n\n","category":"method"},{"location":"api/#WhatsThePoint.triangle_box_intersection-Union{Tuple{T}, NTuple{5, StaticArraysCore.SVector{3, T}}} where T<:Real","page":"API","title":"WhatsThePoint.triangle_box_intersection","text":"triangle_box_intersection(\n    v1::SVector{3,T},\n    v2::SVector{3,T},\n    v3::SVector{3,T},\n    box_min::SVector{3,T},\n    box_max::SVector{3,T}\n) where {T<:Real} -> Bool\n\nTest if triangle (v1, v2, v3) intersects axis-aligned box.\n\nUses the Separating Axis Theorem (SAT) with 13 potential separating axes:\n\n3 box face normals (x, y, z axes)\n1 triangle normal\n9 edge-edge cross products\n\nIf any axis separates the triangle and box, they don't intersect.\n\nAlgorithm\n\nTranslate triangle and box so box is centered at origin\nTest each potential separating axis\nReturn false if any axis separates, true otherwise\n\nReferences\n\nAkenine-MÃ¶ller, \"Fast 3D Triangle-Box Overlap Testing\" (2001)\nEricson, \"Real-Time Collision Detection\", Chapter 5.2.9\n\nPerformance\n\nOptimized with early-out tests. Average case is much faster than worst case.\n\n\n\n\n\n","category":"method"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This guide walks through the core workflow: importing a surface, generating volume points, optimizing the distribution, and preparing the point cloud for a meshless solver.","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"] add https://github.com/JuliaMeshless/WhatsThePoint.jl","category":"section"},{"location":"getting_started/#Importing-a-Surface","page":"Getting Started","title":"Importing a Surface","text":"Load a surface mesh (STL, OBJ, or any format supported by GeoIO.jl) as a PointBoundary:\n\nusing WhatsThePoint\n\nboundary = PointBoundary(\"model.stl\")\n\nThe boundary uses face centers as points (not mesh vertices). Each surface element stores a point, normal vector, and area.","category":"section"},{"location":"getting_started/#Inspecting-the-Boundary","page":"Getting Started","title":"Inspecting the Boundary","text":"# Number of boundary points\nlength(boundary)\n\n# Access named surfaces\nnames(boundary)              # surface names\nsurf = surfaces(boundary)[1] # first surface\n\n# Surface element data\npoints(surf)   # point coordinates\nnormals(surf)  # normal vectors\nareas(surf)    # element areas","category":"section"},{"location":"getting_started/#Surface-Operations","page":"Getting Started","title":"Surface Operations","text":"Split surfaces at normal angle discontinuities to identify distinct geometric faces:\n\nsplit_surface!(boundary, 75Â°)\n\nCombine multiple surfaces back into one:\n\ncombine_surfaces!(boundary, \"surface_1\", \"surface_2\")","category":"section"},{"location":"getting_started/#Generating-Volume-Points","page":"Getting Started","title":"Generating Volume Points","text":"Generate volume points from a boundary using discretize. The algorithm choice depends on the problem dimension.","category":"section"},{"location":"getting_started/#3D-Algorithms","page":"Getting Started","title":"3D Algorithms","text":"spacing = ConstantSpacing(1mm)\n\n# SlakKosec (default for 3D) â€” sphere-based candidate generation\ncloud = discretize(boundary, spacing; alg=SlakKosec())\n\n# VanDerSandeFornberg â€” grid projection with sphere packing\ncloud = discretize(boundary, spacing; alg=VanDerSandeFornberg(), max_points=100_000)\n\n# OctreeRandom â€” octree-guided random generation (no spacing needed)\ncloud = discretize(boundary, OctreeRandom(\"model.stl\"; h_min=0.5))\n\nSlakKosec can also accept a TriangleOctree for accelerated point-in-volume queries:\n\noctree = TriangleOctree(\"model.stl\"; h_min=0.5)\ncloud = discretize(boundary, spacing; alg=SlakKosec(octree))","category":"section"},{"location":"getting_started/#2D-Algorithm","page":"Getting Started","title":"2D Algorithm","text":"# FornbergFlyer (default and only option for 2D)\ncloud = discretize(boundary, spacing; alg=FornbergFlyer())","category":"section"},{"location":"getting_started/#Spacing-Types","page":"Getting Started","title":"Spacing Types","text":"Control point density with different spacing strategies:\n\n# Uniform spacing everywhere\nspacing = ConstantSpacing(1mm)\n\n# Variable spacing â€” denser near boundary, coarser in interior\nspacing = LogLike(cloud, 0.5mm, 1.2)  # base_size, growth_rate\n\nSee the Discretization page for detailed descriptions of each algorithm and spacing type.","category":"section"},{"location":"getting_started/#Node-Repulsion","page":"Getting Started","title":"Node Repulsion","text":"Optimize the point distribution using the repulsion algorithm (Miotti 2023). This improves point regularity which is important for meshless PDE accuracy:\n\ncloud, convergence = repel(cloud, spacing; Î²=0.2, max_iters=1000)\n\nrepel returns a tuple of (new_cloud, convergence_vector). The new cloud has NoTopology since points have moved.","category":"section"},{"location":"getting_started/#Topology-(Point-Connectivity)","page":"Getting Started","title":"Topology (Point Connectivity)","text":"Meshless methods require a stencil (set of neighbor points) for each point. Compute this with set_topology:\n\n# k-nearest neighbors\ncloud = set_topology(cloud, KNNTopology, 21)\n\n# Or radius-based neighbors\ncloud = set_topology(cloud, RadiusTopology, 2mm)\n\n# Access neighbor indices\nneighbors(cloud, 5)   # neighbors of point 5\nneighbors(cloud)       # all neighborhoods\n\n# Check state\nhastopology(cloud)     # true\n\nTopology can also be set on individual surfaces and volumes:\n\nsurf = set_topology(surf, KNNTopology, 10)\nneighbors(surf, i)  # local indices within the surface","category":"section"},{"location":"getting_started/#Visualization","page":"Getting Started","title":"Visualization","text":"Visualize point clouds and boundaries using Makie.jl:\n\nusing GLMakie\n\nvisualize(cloud; markersize=0.15)\nvisualize(boundary; markersize=0.15)\nvisualize_normals(boundary)","category":"section"},{"location":"getting_started/#Export","page":"Getting Started","title":"Export","text":"Save a point cloud to VTK format for use in external tools:\n\nexport_cloud(\"output.vtk\", cloud)","category":"section"},{"location":"octree/#Octree","page":"Octree","title":"Octree","text":"WhatsThePoint provides an octree data structure for accelerating spatial queries on triangle meshes. The primary type is TriangleOctree, which subdivides 3D space around a surface mesh and classifies leaf nodes as interior, boundary, or exterior.","category":"section"},{"location":"octree/#TriangleOctree","page":"Octree","title":"TriangleOctree","text":"","category":"section"},{"location":"octree/#Construction","page":"Octree","title":"Construction","text":"Build a TriangleOctree from a mesh file or a SimpleMesh:\n\nusing WhatsThePoint\n\n# From a file path\noctree = TriangleOctree(\"model.stl\"; h_min=0.5)\n\n# From a SimpleMesh\nusing GeoIO\nmesh = GeoIO.load(\"model.stl\") |> boundary\noctree = TriangleOctree(mesh; h_min=0.5)\n\nParameters:\n\nh_min (required) â€” Minimum box size. Controls the finest resolution of the octree.\nmax_triangles_per_box â€” Maximum triangles per leaf before subdivision (default: 50).\nclassify_leaves â€” Whether to classify empty leaves as interior/exterior (default: true).\nverify_orientation â€” Check mesh normal consistency before building (default: true).","category":"section"},{"location":"octree/#Construction-Process","page":"Octree","title":"Construction Process","text":"Create a root box enclosing the mesh bounding box (with a small buffer)\nDistribute triangles into leaves, subdividing when a leaf has too many triangles or is larger than h_min\nBalance the tree to enforce a 2:1 refinement constraint (no adjacent leaves differ by more than one level)\nClassify empty leaves as interior or exterior using signed distance queries","category":"section"},{"location":"octree/#Leaf-Classification","page":"Octree","title":"Leaf Classification","text":"Each leaf in the octree is classified as one of:\n\nInterior â€” Entirely inside the mesh surface\nExterior â€” Entirely outside the mesh surface\nBoundary â€” Contains or is near the mesh surface\n\nThis classification enables O(1) point-in-volume queries for interior and exterior leaves.","category":"section"},{"location":"octree/#Octree-Accelerated-isinside","page":"Octree","title":"Octree-Accelerated isinside","text":"The primary use of TriangleOctree is fast point-in-volume testing:\n\noctree = TriangleOctree(\"model.stl\"; h_min=0.5)\n\n# Single point query\nresult = isinside(point, octree)\n\n# Batch query\nresults = isinside(points, octree)\n\nPerformance: For interior and exterior leaves, the result is a direct array lookup â€” O(1). For boundary leaves, a local signed distance is computed using only the triangles in that leaf â€” O(k) where k is typically 10â€“50 triangles. This is dramatically faster than the default O(M) Green's function approach for large meshes.\n\nBoth SVector{3} and Meshes.jl Point types are accepted.","category":"section"},{"location":"octree/#Integration-with-Discretization","page":"Octree","title":"Integration with Discretization","text":"","category":"section"},{"location":"octree/#SlakKosec-with-Octree","page":"Octree","title":"SlakKosec with Octree","text":"Pass a TriangleOctree to SlakKosec to accelerate the isinside checks during volume point generation:\n\noctree = TriangleOctree(\"model.stl\"; h_min=0.5)\nspacing = ConstantSpacing(1mm)\ncloud = discretize(boundary, spacing; alg=SlakKosec(octree))","category":"section"},{"location":"octree/#Using-OctreeRandom","page":"Octree","title":"Using OctreeRandom","text":"OctreeRandom uses the octree directly to generate volume points. See the Discretization page for details.\n\ncloud = discretize(boundary, OctreeRandom(\"model.stl\"; h_min=0.5))","category":"section"},{"location":"octree/#Query-Functions","page":"Octree","title":"Query Functions","text":"num_leaves(octree)                 # Number of leaf nodes\nnum_triangles(octree)              # Number of triangles in the mesh\nhas_consistent_normals(mesh)       # Check if mesh normals are consistently oriented","category":"section"},{"location":"discretization/#Discretization","page":"Discretization","title":"Discretization","text":"Volume discretization generates interior points from a boundary surface. The discretize function dispatches to dimension-specific algorithms.\n\ncloud = discretize(boundary, spacing; alg=algorithm, max_points=10_000_000)","category":"section"},{"location":"discretization/#Algorithm-Overview","page":"Discretization","title":"Algorithm Overview","text":"Algorithm Dimensions Spacing Required Description\nSlakKosec 3D Yes Sphere-based candidate generation\nVanDerSandeFornberg 3D Yes (ConstantSpacing only) Grid projection with sphere packing\nFornbergFlyer 2D Yes (ConstantSpacing only) 1D projection with height-field fill\nOctreeRandom 3D No Octree-guided random point generation","category":"section"},{"location":"discretization/#SlakKosec","page":"Discretization","title":"SlakKosec","text":"Default algorithm for 3D discretization. Generates candidate points on spheres around existing points, accepting those that are inside the domain and sufficiently far from existing points.\n\n# Basic usage\ncloud = discretize(boundary, spacing; alg=SlakKosec())\n\n# Custom number of candidates per sphere (default: 10)\ncloud = discretize(boundary, spacing; alg=SlakKosec(20))\n\n# With octree acceleration for faster isinside queries\noctree = TriangleOctree(\"model.stl\"; h_min=0.5)\ncloud = discretize(boundary, spacing; alg=SlakKosec(octree))\ncloud = discretize(boundary, spacing; alg=SlakKosec(20, octree))\n\nSupports both ConstantSpacing and variable spacings (LogLike).","category":"section"},{"location":"discretization/#VanDerSandeFornberg","page":"Discretization","title":"VanDerSandeFornberg","text":"3D algorithm that projects a 2D grid onto the shadow plane and fills the volume layer by layer using sphere packing heights.\n\ncloud = discretize(boundary, ConstantSpacing(1mm); alg=VanDerSandeFornberg())\n\nRequires ConstantSpacing. Uses isinside (Green's function) for filtering generated points.","category":"section"},{"location":"discretization/#FornbergFlyer","page":"Discretization","title":"FornbergFlyer","text":"2D-only algorithm. Uses a similar height-field approach as VanDerSandeFornberg, but projects onto the x-axis for 2D domains.\n\ncloud = discretize(boundary, ConstantSpacing(0.1mm); alg=FornbergFlyer())\n\nThis is the default (and only) algorithm for 2D boundaries.","category":"section"},{"location":"discretization/#OctreeRandom","page":"Discretization","title":"OctreeRandom","text":"Generates volume points directly from an octree decomposition of the domain. The octree classifies leaf nodes as interior, boundary, or exterior. Interior leaves are filled with random points directly (100% acceptance rate), while boundary leaves are oversampled and filtered with the octree-accelerated isinside test.\n\nNo spacing parameter is needed â€” point density is controlled by the octree resolution (h_min).\n\n# From a mesh file (recommended â€” auto-computes h_min)\ncloud = discretize(boundary, OctreeRandom(\"model.stl\"))\n\n# With explicit h_min\ncloud = discretize(boundary, OctreeRandom(\"model.stl\"; h_min=0.5))\n\n# From a pre-built TriangleOctree\noctree = TriangleOctree(\"model.stl\"; h_min=0.5)\ncloud = discretize(boundary, OctreeRandom(octree))\n\n# With custom boundary oversampling (default: 2.0)\ncloud = discretize(boundary, OctreeRandom(octree, 3.0))\n\nParameters:\n\nh_min â€” Minimum octree box size. Auto-computed from mesh diagonal and triangle count if omitted.\nmax_triangles_per_box â€” Maximum triangles per leaf before subdivision (default: 50).\nboundary_oversampling â€” Oversampling factor for boundary leaves (default: 2.0). Higher values improve boundary coverage at the cost of more rejected candidates.\nverify_interior â€” Verify generated interior points with isinside (default: false). Usually unnecessary since leaf classification is reliable.\nverify_orientation â€” Check mesh normal consistency before building the octree (default: true).","category":"section"},{"location":"discretization/#Spacing-Types","page":"Discretization","title":"Spacing Types","text":"Spacing controls point density for algorithms that require it (all except OctreeRandom).","category":"section"},{"location":"discretization/#ConstantSpacing","page":"Discretization","title":"ConstantSpacing","text":"Uniform spacing everywhere in the domain:\n\nspacing = ConstantSpacing(1mm)\n\nWorks with all algorithms.","category":"section"},{"location":"discretization/#LogLike","page":"Discretization","title":"LogLike","text":"Variable spacing that is denser near the boundary and coarser in the interior. Uses a logarithmic-like growth function:\n\nspacing = LogLike(cloud, base_size, growth_rate)\n\nbase_size â€” Spacing at the boundary surface.\ngrowth_rate â€” Rate at which spacing increases away from the boundary. Values > 1 create coarser interior points.\n\nThe spacing at a point is computed as base_size * x / (a + x) where x is the distance to the nearest boundary point.\n\nWorks with SlakKosec only.","category":"section"},{"location":"discretization/#Power","page":"Discretization","title":"Power","text":"warning: Warning\nPower spacing is declared but not yet functional. Its constructor currently throws an error.","category":"section"},{"location":"#WhatsThePoint.jl","page":"Home","title":"WhatsThePoint.jl","text":"(Image: Build Status) (Image: Stable) (Image: Dev) (Image: License File)\n\nDocumentation for WhatsThePoint.\n\nThis package provides tools for generating and manipulating point clouds for meshless PDE methods. It handles the full workflow from surface mesh import through volume discretization, point distribution optimization, and connectivity computation.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Simply install the latest stable release using Julia's package manager:\n\n] add https://github.com/JuliaMeshless/WhatsThePoint.jl","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"Although there are a number of features in this package, the initial use case is for generating point clouds for use in numerical solution of PDEs via a meshless method.\n\nYou can load a surface mesh and extract the boundary points using the PointBoundary constructor.\n\nusing WhatsThePoint\nboundary = PointBoundary(joinpath(@__DIR__, \"assets/bunny.stl\"))\n\nand we can visualize it with\n\nusing GLMakie\nvisualize(boundary; markersize=0.15)\n\n(Image: bunny boundary)\n\nThen we can generate a point cloud using discretize.\n\nspacing = ConstantSpacing(1m)\ncloud = discretize(boundary, spacing; alg=VanDerSandeFornberg(), max_points=100_000)\n\nand we can visualize again with visualize(cloud; markersize=0.15)\n\n(Image: bunny discretized)","category":"section"},{"location":"#Octree-Accelerated-Discretization","page":"Home","title":"Octree-Accelerated Discretization","text":"For large meshes, you can use OctreeRandom which builds an octree from the surface mesh and generates volume points directly from the tree structure â€” no spacing parameter needed:\n\ncloud = discretize(boundary, OctreeRandom(\"model.stl\"; h_min=0.5))\n\nOr pass a pre-built TriangleOctree to SlakKosec for accelerated point-in-volume queries:\n\noctree = TriangleOctree(\"model.stl\"; h_min=0.5)\ncloud = discretize(boundary, spacing; alg=SlakKosec(octree))\n\nSee the Octree and Discretization pages for details.","category":"section"},{"location":"#Adding-Topology-(Point-Connectivity)","page":"Home","title":"Adding Topology (Point Connectivity)","text":"For meshless PDE solvers, you often need to know the neighbors of each point (the stencil). WhatsThePoint can compute and store this connectivity:\n\n# Add k-nearest neighbor topology (21 neighbors per point)\ncloud = set_topology(cloud, KNNTopology, 21)\n\n# Access neighbors\nall_neighbors = neighbors(cloud)        # Vector{Vector{Int}}\npoint_5_neighbors = neighbors(cloud, 5) # neighbors of point 5\n\n# Check topology state\nhastopology(cloud)  # true\n\nAlternatively, use radius-based topology where all points within a given distance are neighbors:\n\ncloud = set_topology(cloud, RadiusTopology, 2mm)\n\nnote: Note\nset_topology returns a new object with the computed topology. Operations that move points (like repel) also return new objects with NoTopology, since the connectivity is no longer valid after points have moved. Simply call set_topology again after repulsion.","category":"section"}]
}
