<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API ¬∑ WhatsThePoint.jl</title><meta name="title" content="API ¬∑ WhatsThePoint.jl"/><meta property="og:title" content="API ¬∑ WhatsThePoint.jl"/><meta property="twitter:title" content="API ¬∑ WhatsThePoint.jl"/><meta name="description" content="Documentation for WhatsThePoint.jl."/><meta property="og:description" content="Documentation for WhatsThePoint.jl."/><meta property="twitter:description" content="Documentation for WhatsThePoint.jl."/><meta property="og:url" content="https://JuliaMeshless.github.io/WhatsThePoint.jl/api/"/><meta property="twitter:url" content="https://JuliaMeshless.github.io/WhatsThePoint.jl/api/"/><link rel="canonical" href="https://JuliaMeshless.github.io/WhatsThePoint.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="WhatsThePoint.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">WhatsThePoint.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../discretization/">Discretization</a></li><li><a class="tocitem" href="../octree/">Octree</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Exported-Functions"><span>Exported Functions</span></a></li><li><a class="tocitem" href="#Private"><span>Private</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Exported-Functions"><a class="docs-heading-anchor" href="#Exported-Functions">Exported Functions</a><a id="Exported-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="WhatsThePoint.AbstractSurface"><a class="docstring-binding" href="#WhatsThePoint.AbstractSurface"><code>WhatsThePoint.AbstractSurface</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractSurface{M&lt;:Manifold,C&lt;:CRS} end</code></pre><p>A surface of a <a href="#WhatsThePoint.PointSurface">PointSurface</a>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.AbstractTopology"><a class="docstring-binding" href="#WhatsThePoint.AbstractTopology"><code>WhatsThePoint.AbstractTopology</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractTopology{S}</code></pre><p>Abstract base type for point cloud topology (connectivity). Type parameter <code>S</code> is the storage format for neighbor indices.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.ConstantSpacing"><a class="docstring-binding" href="#WhatsThePoint.ConstantSpacing"><code>WhatsThePoint.ConstantSpacing</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConstantSpacing{L&lt;:Unitful.Length} &lt;: AbstractSpacing</code></pre><p>Constant node spacing.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.KNNTopology"><a class="docstring-binding" href="#WhatsThePoint.KNNTopology"><code>WhatsThePoint.KNNTopology</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct KNNTopology{S} &lt;: AbstractTopology{S}</code></pre><p>k-nearest neighbors topology.</p><p><strong>Fields</strong></p><ul><li><code>neighbors::S</code> - neighbor indices storage</li><li><code>k::Int</code> - number of neighbors per point</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.LogLike"><a class="docstring-binding" href="#WhatsThePoint.LogLike"><code>WhatsThePoint.LogLike</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LogLike &lt;: VariableSpacing</code></pre><p>Node spacing based on a log-like function of the distance to nearest boundary <span>$x/(x+a)$</span>     where <span>$x$</span> is the distance to the nearest boundary and <span>$a$</span> is a parameter to control     the growth rate as <span>$a = 1 - (g - 1)$</span> where <span>$g$</span> is the conventional growth rate     parameter.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.NoTopology"><a class="docstring-binding" href="#WhatsThePoint.NoTopology"><code>WhatsThePoint.NoTopology</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct NoTopology &lt;: AbstractTopology{Nothing}</code></pre><p>Singleton type representing no topology. Default for PointCloud.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.OctreeRandom"><a class="docstring-binding" href="#WhatsThePoint.OctreeRandom"><code>WhatsThePoint.OctreeRandom</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OctreeRandom &lt;: AbstractNodeGenerationAlgorithm</code></pre><p>Octree-guided random point generation for volume discretization.</p><p>This algorithm uses a <code>TriangleOctree</code> with leaf classification to efficiently generate random points inside the mesh. It&#39;s much faster than rejection sampling because:</p><ul><li>Only samples in interior/boundary regions (skips exterior entirely)</li><li>Interior boxes need no filtering (100% acceptance rate)</li><li>Only boundary boxes require isinside() checks</li></ul><p><strong>Fields</strong></p><ul><li><code>octree::TriangleOctree</code> - Octree with leaf classification</li><li><code>boundary_oversampling::Float64</code> - Oversampling factor for boundary boxes (default: 2.0)</li><li><code>verify_interior::Bool</code> - Per-point signed distance verification for interior leaves (default: false)</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs"># From mesh (recommended) ‚Äî builds octree automatically with classified leaves
OctreeRandom(mesh::SimpleMesh)                          # Auto h_min
OctreeRandom(mesh; h_min=0.01, boundary_oversampling=2.0)  # Custom h_min

# From file path ‚Äî loads mesh then builds octree
OctreeRandom(&quot;bunny.stl&quot;)
OctreeRandom(&quot;bunny.stl&quot;; h_min=0.01)

# From pre-built octree (advanced)
OctreeRandom(octree::TriangleOctree)
OctreeRandom(octree, oversampling; verify_interior=false)</code></pre><p><strong>Performance</strong></p><ul><li><strong>Interior leaves</strong>: O(1) per point (no filtering needed)</li><li><strong>Boundary leaves</strong>: O(k) per point where k ‚âà 10-50 triangles</li><li><strong>Much faster than bounding box rejection</strong>: Typical acceptance 5-20% vs 90%+ here</li></ul><p><strong>Usage Examples</strong></p><p><strong>Recommended Usage</strong></p><pre><code class="language-julia hljs">using WhatsThePoint

mesh = GeoIO.load(&quot;bunny.stl&quot;).geometry
boundary = PointBoundary(mesh)
cloud = discretize(boundary, OctreeRandom(mesh); max_points=100_000)</code></pre><p><strong>With Spacing (backward compatible)</strong></p><pre><code class="language-julia hljs">octree = TriangleOctree(mesh; h_min=0.01, classify_leaves=true)
cloud = discretize(boundary, 1.0u&quot;m&quot;; alg=OctreeRandom(octree), max_points=10_000)</code></pre><p><strong>With Custom Oversampling</strong></p><pre><code class="language-julia hljs">alg = OctreeRandom(mesh; boundary_oversampling=2.5)
cloud = discretize(boundary, alg; max_points=10_000)</code></pre><p><strong>Notes</strong></p><ul><li>The mesh convenience constructor always sets <code>classify_leaves=true</code></li><li>When <code>h_min</code> is omitted, it is computed as <code>bbox_diagonal / (2 * cbrt(n_triangles))</code></li><li>The <code>spacing</code> parameter is <strong>not used</strong> (random uniform distribution)</li><li>For spacing-based discretization, use SlakKosec or VanDerSandeFornberg</li><li>Actual point count may be slightly less than <code>max_points</code> due to boundary filtering</li><li>Oversampling 1.5-3.0 is recommended; higher values waste computation</li></ul><p><strong>Algorithm Details</strong></p><ol><li><strong>Identify regions</strong>: Separate octree leaves into interior (2) and boundary (1)</li><li><strong>Allocate points</strong>: Distribute target count proportionally to leaf volumes</li><li><strong>Generate interior points</strong>: Random sampling in interior boxes (no filtering)</li><li><strong>Generate boundary points</strong>: Oversample and filter with isinside()</li><li><strong>Return</strong>: Combined set of validated interior points</li></ol><p><strong>When to Use</strong></p><p><strong>Good for</strong>:</p><ul><li>Quick initial discretization</li><li>Uniform random distributions</li><li>Maximum point count targets</li><li>Testing and prototyping</li></ul><p><strong>Not ideal for</strong>:</p><ul><li>Spacing-controlled discretization (use SlakKosec instead)</li><li>Adaptive refinement</li><li>Smooth point distributions</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.OctreeRandom-Tuple{String}"><a class="docstring-binding" href="#WhatsThePoint.OctreeRandom-Tuple{String}"><code>WhatsThePoint.OctreeRandom</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">OctreeRandom(filepath::String; kwargs...)</code></pre><p>Load a mesh from <code>filepath</code> and build an <code>OctreeRandom</code> algorithm. Accepts the same keyword arguments as <code>OctreeRandom(mesh; ...)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">alg = OctreeRandom(&quot;bunny.stl&quot;)
cloud = discretize(boundary, alg; max_points=100_000)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.OctreeRandom-Union{Tuple{Meshes.SimpleMesh{M, C, V} where V&lt;:AbstractArray{Point{M, C}, 1}}, Tuple{C}, Tuple{M}} where {M&lt;:Meshes.Manifold, C&lt;:CoordRefSystems.CRS}"><a class="docstring-binding" href="#WhatsThePoint.OctreeRandom-Union{Tuple{Meshes.SimpleMesh{M, C, V} where V&lt;:AbstractArray{Point{M, C}, 1}}, Tuple{C}, Tuple{M}} where {M&lt;:Meshes.Manifold, C&lt;:CoordRefSystems.CRS}"><code>WhatsThePoint.OctreeRandom</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">OctreeRandom(mesh::SimpleMesh; h_min=nothing, max_triangles_per_box=50,
             boundary_oversampling=2.0, verify_interior=false, verify_orientation=true)</code></pre><p>Convenience constructor that builds a classified <code>TriangleOctree</code> internally.</p><p>When <code>h_min</code> is not provided, an automatic value is computed from the mesh&#39;s bounding box diagonal and triangle count.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mesh = GeoIO.load(&quot;bunny.stl&quot;).geometry
alg = OctreeRandom(mesh)
cloud = discretize(boundary, alg; max_points=100_000)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.PointBoundary"><a class="docstring-binding" href="#WhatsThePoint.PointBoundary"><code>WhatsThePoint.PointBoundary</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct PointBoundary{M,C} &lt;: Domain{M,C}</code></pre><p>A boundary of points.</p><p><strong>Fields</strong></p><ul><li><code>surfaces</code>: Named surfaces forming the boundary</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>M &lt;: Manifold</code>: The manifold type</li><li><code>C &lt;: CRS</code>: The coordinate reference system</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.PointBoundary-Tuple{Meshes.SimpleMesh}"><a class="docstring-binding" href="#WhatsThePoint.PointBoundary-Tuple{Meshes.SimpleMesh}"><code>WhatsThePoint.PointBoundary</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PointBoundary(mesh::SimpleMesh)</code></pre><p>Create a <code>PointBoundary</code> from a <code>SimpleMesh</code>  by taking the centroids of its elements as points,  and computing normals and areas accordingly.</p><p>(IMPORTANT: does not use any fancy node sampling,  depends on the mesh&#39;s discretization, and is not guaranteed  to be a good representation of the original geometry.  Use with caution.)</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.PointCloud"><a class="docstring-binding" href="#WhatsThePoint.PointCloud"><code>WhatsThePoint.PointCloud</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct PointCloud{M,C,T} &lt;: Domain{M,C}</code></pre><p>A point cloud with optional topology (connectivity).</p><p><strong>Type Parameters</strong></p><ul><li><code>M&lt;:Manifold</code> - manifold type</li><li><code>C&lt;:CRS</code> - coordinate reference system</li><li><code>T&lt;:AbstractTopology</code> - topology type for cloud-level connectivity</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.PointSurface"><a class="docstring-binding" href="#WhatsThePoint.PointSurface"><code>WhatsThePoint.PointSurface</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct PointSurface{M,C,S,T} &lt;: AbstractSurface{M,C}</code></pre><p>This is a typical representation of a surface via points.</p><p><strong>Type Parameters</strong></p><ul><li><code>M&lt;:Manifold</code> - manifold type</li><li><code>C&lt;:CRS</code> - coordinate reference system</li><li><code>S</code> - shadow type</li><li><code>T&lt;:AbstractTopology</code> - topology type for surface-local connectivity</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.PointVolume"><a class="docstring-binding" href="#WhatsThePoint.PointVolume"><code>WhatsThePoint.PointVolume</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct PointVolume{M,C,T,V} &lt;: Domain{M,C}</code></pre><p>Interior volume points with optional topology.</p><p><strong>Type Parameters</strong></p><ul><li><code>M&lt;:Manifold</code> - manifold type</li><li><code>C&lt;:CRS</code> - coordinate reference system</li><li><code>T&lt;:AbstractTopology</code> - topology type for volume-local connectivity</li><li><code>V&lt;:AbstractVector{Point{M,C}}</code> - storage type (allows GPU arrays)</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.Power"><a class="docstring-binding" href="#WhatsThePoint.Power"><code>WhatsThePoint.Power</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Power &lt;: VariableSpacing</code></pre><p>Node spacing based on a power of the distance to nearest boundary <span>$x^{g}$</span> where <span>$x$</span> is     the distance to the nearest boundary and <span>$g$</span> is the growth_rate.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.RadiusTopology"><a class="docstring-binding" href="#WhatsThePoint.RadiusTopology"><code>WhatsThePoint.RadiusTopology</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct RadiusTopology{S,R} &lt;: AbstractTopology{S}</code></pre><p>Radius-based topology where neighbors are all points within a given radius.</p><p><strong>Fields</strong></p><ul><li><code>neighbors::S</code> - neighbor indices storage</li><li><code>radius::R</code> - search radius (scalar or function of position)</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.SlakKosec"><a class="docstring-binding" href="#WhatsThePoint.SlakKosec"><code>WhatsThePoint.SlakKosec</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SlakKosec &lt;: AbstractNodeGenerationAlgorithm</code></pre><p>Slak-Kosec algorithm for volume point generation with optional octree acceleration.</p><p>The algorithm generates candidate points on spheres around existing points and accepts them if they are inside the domain and sufficiently far from existing points.</p><p><strong>Fields</strong></p><ul><li><code>n::Int</code> - Number of candidate points per sphere (default: 10)</li><li><code>octree::Union{Nothing,TriangleOctree}</code> - Optional octree for fast isinside queries</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SlakKosec()                          # Default: n=10, no octree
SlakKosec(20)                        # Custom n, no octree
SlakKosec(octree::TriangleOctree)    # Use octree acceleration with n=10
SlakKosec(20, octree)                # Custom n with octree acceleration</code></pre><p><strong>Performance</strong></p><ul><li><strong>Without octree</strong>: Uses Green&#39;s function for isinside (~50ms per query)</li><li><strong>With octree</strong>: Uses spatial indexing (~0.05ms per query, 1000√ó faster!)</li></ul><p><strong>Usage Examples</strong></p><p><strong>Standard Usage (Green&#39;s function)</strong></p><pre><code class="language-julia hljs">using WhatsThePoint

# Load boundary
boundary = PointBoundary(&quot;model.stl&quot;)
cloud = PointCloud(boundary)

# Discretize without octree (slow for large domains)
spacing = ConstantSpacing(1.0u&quot;m&quot;)
result = discretize(cloud, spacing; alg=SlakKosec(), max_points=10_000)</code></pre><p><strong>Octree-Accelerated Usage (Recommended for large domains)</strong></p><pre><code class="language-julia hljs">using WhatsThePoint

# Load boundary points
boundary = PointBoundary(&quot;model.stl&quot;)
cloud = PointCloud(boundary)

# Build octree from STL file (Option 1: simplest)
octree = TriangleOctree(&quot;model.stl&quot;; h_min=0.01, classify_leaves=true)

# Or from SimpleMesh (Option 2)
# mesh = GeoIO.load(&quot;model.stl&quot;).geometry
# octree = TriangleOctree(mesh; h_min=0.01, classify_leaves=true)

# Use octree-accelerated discretization (100-1000√ó faster!)
spacing = ConstantSpacing(1.0u&quot;m&quot;)
alg = SlakKosec(octree)  # Pass octree to algorithm
result = discretize(cloud, spacing; alg=alg, max_points=100_000)</code></pre><p><strong>References</strong></p><p>≈†lak J, Kosec G. &quot;On generation of node distributions for meshless PDE discretizations&quot; (2019)</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.SurfaceElement"><a class="docstring-binding" href="#WhatsThePoint.SurfaceElement"><code>WhatsThePoint.SurfaceElement</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SurfaceElement{M,C,N,A}</code></pre><p>Representation of a point on a <code>&lt;:PointSurface</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.TriangleOctree"><a class="docstring-binding" href="#WhatsThePoint.TriangleOctree"><code>WhatsThePoint.TriangleOctree</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TriangleOctree{M&lt;:Manifold, C&lt;:CRS, T&lt;:Real}</code></pre><p>An octree-based spatial index for efficient triangle mesh queries.</p><p><strong>Fields</strong></p><ul><li><code>tree::SpatialOctree{Int,T}</code>: Underlying octree storing triangle indices</li><li><code>mesh::SimpleMesh{M,C}</code>: Original Meshes.jl mesh (single source of truth for triangle data)</li><li><code>leaf_classification::Union{Nothing, Vector{Int8}}</code>: Classification of empty leaves<ul><li><code>0</code>: Exterior (outside mesh)</li><li><code>1</code>: Boundary (near surface but empty)</li><li><code>2</code>: Interior (inside mesh)</li></ul></li></ul><p><strong>Performance</strong></p><p>For a mesh with M triangles:</p><ul><li>Construction: O(M log M) - distribute triangles to boxes</li><li>Query: O(log M + k) where k ‚âà 10-50 triangles per leaf</li><li>Memory: O(N) for octree nodes (mesh data accessed on-the-fly)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Option 1: From STL file (simplest)
octree = TriangleOctree(&quot;model.stl&quot;; h_min=0.01, classify_leaves=true)

# Option 2: From SimpleMesh
mesh = GeoIO.load(&quot;model.stl&quot;).geometry
octree = TriangleOctree(mesh; h_min=0.01, classify_leaves=true)

# Fast queries (100-1000x speedup over brute force)
point = SVector(0.5, 0.5, 0.5)
is_inside = isinside(point, octree)</code></pre><p><strong>Workflow with PointBoundary</strong></p><p>Since PointBoundary discards mesh topology, build both from the same mesh:</p><pre><code class="language-julia hljs">mesh = GeoIO.load(&quot;model.stl&quot;).geometry
boundary = PointBoundary(mesh)
octree = TriangleOctree(mesh; h_min=0.01, classify_leaves=true)
cloud = discretize(boundary, spacing; alg=OctreeRandom(octree))</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.TriangleOctree-Tuple{String}"><a class="docstring-binding" href="#WhatsThePoint.TriangleOctree-Tuple{String}"><code>WhatsThePoint.TriangleOctree</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TriangleOctree(filepath::String; h_min, kwargs...) -&gt; TriangleOctree</code></pre><p>Build an octree spatial index from an STL file.</p><p><strong>Arguments</strong></p><ul><li><code>filepath::String</code>: Path to STL file</li><li><code>h_min</code>: Minimum octree box size</li><li><code>kwargs...</code>: Additional arguments passed to TriangleOctree(mesh; ...)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">octree = TriangleOctree(&quot;model.stl&quot;; h_min=0.01, classify_leaves=true)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.TriangleOctree-Union{Tuple{Meshes.SimpleMesh{M, C, V} where V&lt;:AbstractArray{Point{M, C}, 1}}, Tuple{C}, Tuple{M}} where {M&lt;:Meshes.Manifold, C&lt;:CoordRefSystems.CRS}"><a class="docstring-binding" href="#WhatsThePoint.TriangleOctree-Union{Tuple{Meshes.SimpleMesh{M, C, V} where V&lt;:AbstractArray{Point{M, C}, 1}}, Tuple{C}, Tuple{M}} where {M&lt;:Meshes.Manifold, C&lt;:CoordRefSystems.CRS}"><code>WhatsThePoint.TriangleOctree</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TriangleOctree(mesh::SimpleMesh{M,C};
               h_min,
               max_triangles_per_box::Int=50,
               classify_leaves::Bool=true,
               verify_orientation::Bool=true) -&gt; TriangleOctree{M,C,Float64}</code></pre><p>Build an octree spatial index for a SimpleMesh.</p><p><strong>Arguments</strong></p><ul><li><code>mesh::SimpleMesh{M,C}</code>: Meshes.jl SimpleMesh to index</li><li><code>h_min</code>: Minimum octree box size (stopping criterion)</li><li><code>max_triangles_per_box::Int=50</code>: Maximum triangles per leaf before subdivision</li><li><code>classify_leaves::Bool=true</code>: Whether to classify empty leaves as interior/exterior</li><li><code>verify_orientation::Bool=true</code>: Check if triangle normals are consistently oriented</li></ul><p><strong>Algorithm</strong></p><ol><li>(Optional) Verify triangle normal consistency</li><li>Create root octree covering mesh bounding box</li><li>Distribute triangles to boxes using SAT intersection tests</li><li>Recursively subdivide boxes exceeding triangle threshold</li><li>Balance octree to ensure 2:1 refinement constraint</li><li>(Optional) Classify empty leaves via signed-distance tests</li></ol><p><strong>Returns</strong></p><p><code>TriangleOctree{M,C,T}</code> ready for fast spatial queries (T defaults to Float64)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mesh = GeoIO.load(&quot;box.stl&quot;).geometry
octree = TriangleOctree(mesh; h_min=0.01, max_triangles_per_box=50)
println(&quot;Built octree with &quot;, num_leaves(octree), &quot; leaves&quot;)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="Meshes.boundingbox-Union{Tuple{AbstractVector{&lt;:Point{M, C}}}, Tuple{C}, Tuple{M}} where {M, C}"><a class="docstring-binding" href="#Meshes.boundingbox-Union{Tuple{AbstractVector{&lt;:Point{M, C}}}, Tuple{C}, Tuple{M}} where {M, C}"><code>Meshes.boundingbox</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">boundingbox(pts::AbstractVector{&lt;:Point})</code></pre><p>Compute the axis-aligned bounding box of a collection of points.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="Meshes.centroid-Union{Tuple{AbstractVector{&lt;:Point{M, C}}}, Tuple{C}, Tuple{M}} where {M, C}"><a class="docstring-binding" href="#Meshes.centroid-Union{Tuple{AbstractVector{&lt;:Point{M, C}}}, Tuple{C}, Tuple{M}} where {M, C}"><code>Meshes.centroid</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">centroid(pts::AbstractVector{&lt;:Point})</code></pre><p>Compute the centroid (geometric center) of a collection of points.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="Meshes.discretize-Tuple{PointBoundary{Meshes.ùîº{3}}, AbstractSpacing}"><a class="docstring-binding" href="#Meshes.discretize-Tuple{PointBoundary{Meshes.ùîº{3}}, AbstractSpacing}"><code>Meshes.discretize</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">discretize(bnd::PointBoundary, spacing; alg=auto, max_points=10_000_000)</code></pre><p>Generate volume points for the given boundary and return a new PointCloud.</p><p><code>spacing</code> can be either an <code>AbstractSpacing</code> object or a bare <code>Unitful.Length</code> value (which will be wrapped in <code>ConstantSpacing</code>).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>alg</code>: Discretization algorithm (default: <code>SlakKosec()</code> for 3D)</li><li><code>max_points</code>: Maximum number of volume points to generate</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">mesh = GeoIO.load(&quot;model.stl&quot;).geometry
boundary = PointBoundary(mesh)
octree = TriangleOctree(mesh; h_min=0.1)
cloud = discretize(boundary, 3.0m; alg=SlakKosec(octree), max_points=100_000)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="Meshes.discretize-Tuple{PointBoundary{Meshes.ùîº{3}}, OctreeRandom}"><a class="docstring-binding" href="#Meshes.discretize-Tuple{PointBoundary{Meshes.ùîº{3}}, OctreeRandom}"><code>Meshes.discretize</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">discretize(bnd::PointBoundary{ùîº{3}}, alg::OctreeRandom; max_points=10_000_000)</code></pre><p>Generate volume points using <code>OctreeRandom</code> without requiring a spacing parameter.</p><p>OctreeRandom generates uniformly random points and does not use spacing, so this overload removes the need for a dummy spacing value.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mesh = GeoIO.load(&quot;bunny.stl&quot;).geometry
boundary = PointBoundary(mesh)
cloud = discretize(boundary, OctreeRandom(mesh); max_points=100_000)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="Meshes.discretize-Tuple{PointCloud, AbstractSpacing}"><a class="docstring-binding" href="#Meshes.discretize-Tuple{PointCloud, AbstractSpacing}"><code>Meshes.discretize</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">discretize(cloud::PointCloud, spacing; alg=auto, max_points=10_000_000)</code></pre><p>Generate volume points for an existing cloud and return a new PointCloud with the volume populated.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.compute_normals-Union{Tuple{C}, Tuple{N}, Tuple{KNearestSearch, PointSurface{Meshes.ùîº{N}, C}}} where {N, C&lt;:CoordRefSystems.CRS}"><a class="docstring-binding" href="#WhatsThePoint.compute_normals-Union{Tuple{C}, Tuple{N}, Tuple{KNearestSearch, PointSurface{Meshes.ùîº{N}, C}}} where {N, C&lt;:CoordRefSystems.CRS}"><code>WhatsThePoint.compute_normals</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_normals(search_method::KNearestSearch, surf::PointSurface{ùîº{N},C}) where {N,C&lt;:CRS}</code></pre><p>Estimate the normals of a set of points that form a surface. Uses the PCA approach from &quot;Surface Reconstruction from Unorganized Points&quot; - Hoppe (1992).</p><p>Requires Euclidean manifold (<code>ùîº{2}</code> or <code>ùîº{3}</code>). This function assumes flat space geometry.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.compute_normals-Union{Tuple{PointSurface{Meshes.ùîº{N}, C}}, Tuple{C}, Tuple{N}} where {N, C&lt;:CoordRefSystems.CRS}"><a class="docstring-binding" href="#WhatsThePoint.compute_normals-Union{Tuple{PointSurface{Meshes.ùîº{N}, C}}, Tuple{C}, Tuple{N}} where {N, C&lt;:CoordRefSystems.CRS}"><code>WhatsThePoint.compute_normals</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_normals(surf::PointSurface{ùîº{N},C}; k::Int=5) where {N,C&lt;:CRS}</code></pre><p>Estimate the normals of a set of points that form a surface. Uses the PCA approach from &quot;Surface Reconstruction from Unorganized Points&quot; - Hoppe (1992).</p><p>Requires Euclidean manifold (<code>ùîº{2}</code> or <code>ùîº{3}</code>). This function assumes flat space geometry.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.emptyspace-Union{Tuple{P}, Tuple{P, Vector{P}, Union{Unitful.Quantity{T, ùêã, U}, Unitful.Level{L, S, Unitful.Quantity{T, ùêã, U}} where {L, S}} where {T, U}}} where P&lt;:Point"><a class="docstring-binding" href="#WhatsThePoint.emptyspace-Union{Tuple{P}, Tuple{P, Vector{P}, Union{Unitful.Quantity{T, ùêã, U}, Unitful.Level{L, S, Unitful.Quantity{T, ùêã, U}} where {L, S}} where {T, U}}} where P&lt;:Point"><code>WhatsThePoint.emptyspace</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">emptyspace(testpoint, points)</code></pre><p>Check if a point occupies empty space within a certain tolerance.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.has_consistent_normals-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh}} where T"><a class="docstring-binding" href="#WhatsThePoint.has_consistent_normals-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh}} where T"><code>WhatsThePoint.has_consistent_normals</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_consistent_normals(mesh::SimpleMesh) -&gt; Bool</code></pre><p>Check if triangle faces are consistently oriented (manifold orientation test).</p><p>This function verifies that all shared edges between adjacent triangles are traversed in OPPOSITE directions, which is the geometric requirement for a properly oriented manifold surface. This test is independent of surface curvature.</p><p><strong>Algorithm</strong></p><p>For each shared edge between two triangles:</p><ul><li>Triangle A has edge v1‚Üív2</li><li>Triangle B (adjacent) must have edge v2‚Üív1 (opposite direction)</li><li>If both traverse in the same direction ‚Üí faces are incorrectly oriented</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if all triangles are correctly oriented (manifold surface)</li><li><code>false</code> if any triangles have flipped faces (orientation errors)</li></ul><p><strong>Performance</strong></p><p>O(n) complexity using edge hash map instead of O(n¬≤) pairwise comparison.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">octree = TriangleOctree(&quot;model.stl&quot;; h_min=0.01)
if !has_consistent_normals(octree.mesh)
    @warn &quot;Mesh has flipped triangles - will cause incorrect isinside() results&quot;
end</code></pre><p><strong>Note</strong></p><p>This test uses GEOMETRIC edge orientation, not algebraic normal dot products. It will correctly validate meshes with high curvature (sharp edges, creases).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.hastopology-Tuple{PointCloud}"><a class="docstring-binding" href="#WhatsThePoint.hastopology-Tuple{PointCloud}"><code>WhatsThePoint.hastopology</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hastopology(cloud::PointCloud)</code></pre><p>Check if point cloud has a topology (not NoTopology).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.hastopology-Tuple{PointSurface}"><a class="docstring-binding" href="#WhatsThePoint.hastopology-Tuple{PointSurface}"><code>WhatsThePoint.hastopology</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hastopology(surf::PointSurface)</code></pre><p>Check if surface has a topology (not NoTopology).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.hastopology-Tuple{PointVolume}"><a class="docstring-binding" href="#WhatsThePoint.hastopology-Tuple{PointVolume}"><code>WhatsThePoint.hastopology</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hastopology(vol::PointVolume)</code></pre><p>Check if volume has a topology (not NoTopology).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.isinside-Tuple{AbstractVector{&lt;:Point{Meshes.ùîº{3}}}, TriangleOctree{Meshes.ùîº{3}}}"><a class="docstring-binding" href="#WhatsThePoint.isinside-Tuple{AbstractVector{&lt;:Point{Meshes.ùîº{3}}}, TriangleOctree{Meshes.ùîº{3}}}"><code>WhatsThePoint.isinside</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isinside(points::AbstractVector{&lt;:Point{ùîº{3}}}, octree::TriangleOctree{ùîº{3}}) -&gt; Vector{Bool}</code></pre><p>Batch bridge from Meshes.jl Points to SVector-based isinside.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.isinside-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, TriangleOctree}} where T&lt;:Real"><a class="docstring-binding" href="#WhatsThePoint.isinside-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, TriangleOctree}} where T&lt;:Real"><code>WhatsThePoint.isinside</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isinside(points::Vector{SVector{3,T}}, octree::TriangleOctree) -&gt; Vector{Bool}</code></pre><p>Batch interior test for multiple points.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">test_points = [SVector(randn(3)...) for _ in 1:1000]
results = isinside(test_points, octree)  # Returns Vector{Bool}</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.isinside-Union{Tuple{T}, Tuple{C}, Tuple{Point{Meshes.ùîº{3}}, TriangleOctree{Meshes.ùîº{3}, C, T}}} where {C, T}"><a class="docstring-binding" href="#WhatsThePoint.isinside-Union{Tuple{T}, Tuple{C}, Tuple{Point{Meshes.ùîº{3}}, TriangleOctree{Meshes.ùîº{3}, C, T}}} where {C, T}"><code>WhatsThePoint.isinside</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isinside(point::Point{ùîº{3}}, octree::TriangleOctree{ùîº{3},C,T}) -&gt; Bool</code></pre><p>Bridge from Meshes.jl Point to SVector-based isinside.</p><p>Extracts coordinates from Point, converts to SVector{3,T}, and delegates to the SVector method.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.isinside-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, TriangleOctree}} where T&lt;:Real"><a class="docstring-binding" href="#WhatsThePoint.isinside-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, TriangleOctree}} where T&lt;:Real"><code>WhatsThePoint.isinside</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isinside(point::SVector{3,T}, octree::TriangleOctree) -&gt; Bool</code></pre><p>Fast interior/exterior test using octree spatial index.</p><p>Returns <code>true</code> if point is inside the closed surface defined by the mesh.</p><p><strong>Performance</strong></p><ul><li>Complexity: O(log M + k) where M = number of triangles, k ‚âà 10-50</li><li>Speedup: 100-1000√ó faster than brute-force O(M) approach</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using WhatsThePoint, StaticArrays

octree = TriangleOctree(&quot;model.stl&quot;; h_min=0.01, classify_leaves=true)

point = SVector(0.5, 0.5, 0.5)
is_inside = isinside(point, octree)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.neighbors-Tuple{AbstractTopology, Int64}"><a class="docstring-binding" href="#WhatsThePoint.neighbors-Tuple{AbstractTopology, Int64}"><code>WhatsThePoint.neighbors</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neighbors(t::AbstractTopology, i::Int)</code></pre><p>Return neighbors of point <code>i</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.neighbors-Tuple{AbstractTopology}"><a class="docstring-binding" href="#WhatsThePoint.neighbors-Tuple{AbstractTopology}"><code>WhatsThePoint.neighbors</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neighbors(t::AbstractTopology)</code></pre><p>Return the neighbor storage from a topology.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.neighbors-Tuple{PointCloud, Int64}"><a class="docstring-binding" href="#WhatsThePoint.neighbors-Tuple{PointCloud, Int64}"><code>WhatsThePoint.neighbors</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neighbors(cloud::PointCloud, i::Int)</code></pre><p>Return neighbors of point <code>i</code>. Throws error if no topology or invalid.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.neighbors-Tuple{PointCloud}"><a class="docstring-binding" href="#WhatsThePoint.neighbors-Tuple{PointCloud}"><code>WhatsThePoint.neighbors</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neighbors(cloud::PointCloud)</code></pre><p>Return all neighbor lists from the topology. Throws error if no topology or invalid.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.neighbors-Tuple{PointSurface, Int64}"><a class="docstring-binding" href="#WhatsThePoint.neighbors-Tuple{PointSurface, Int64}"><code>WhatsThePoint.neighbors</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neighbors(surf::PointSurface, i::Int)</code></pre><p>Return neighbors of point <code>i</code> in surface-local indices. Throws error if no topology.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.neighbors-Tuple{PointSurface}"><a class="docstring-binding" href="#WhatsThePoint.neighbors-Tuple{PointSurface}"><code>WhatsThePoint.neighbors</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neighbors(surf::PointSurface)</code></pre><p>Return all neighbor lists from the surface topology. Throws error if no topology.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.neighbors-Tuple{PointVolume, Int64}"><a class="docstring-binding" href="#WhatsThePoint.neighbors-Tuple{PointVolume, Int64}"><code>WhatsThePoint.neighbors</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neighbors(vol::PointVolume, i::Int)</code></pre><p>Return neighbors of point <code>i</code> in volume-local indices. Throws error if no topology.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.neighbors-Tuple{PointVolume}"><a class="docstring-binding" href="#WhatsThePoint.neighbors-Tuple{PointVolume}"><code>WhatsThePoint.neighbors</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neighbors(vol::PointVolume)</code></pre><p>Return all neighbor lists from the volume topology. Throws error if no topology.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.orient_normals!-Tuple{KNearestSearch, AbstractVector{&lt;:AbstractVector}, Any}"><a class="docstring-binding" href="#WhatsThePoint.orient_normals!-Tuple{KNearestSearch, AbstractVector{&lt;:AbstractVector}, Any}"><code>WhatsThePoint.orient_normals!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">orient_normals!(search_method::KNearestSearch, normals::AbstractVector{&lt;:AbstractVector}, points)</code></pre><p>Correct the orientation of normals on a surface as the <a href="#WhatsThePoint.compute_normals-Union{Tuple{C}, Tuple{N}, Tuple{KNearestSearch, PointSurface{Meshes.ùîº{N}, C}}} where {N, C&lt;:CoordRefSystems.CRS}">compute_normals</a> function does not guarantee if the normal is inward or outward facing. Uses the approach from &quot;Surface Reconstruction from Unorganized Points&quot; - Hoppe (1992).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.orient_normals!-Union{Tuple{N}, Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:Point{Meshes.ùîº{N}}}}} where N"><a class="docstring-binding" href="#WhatsThePoint.orient_normals!-Union{Tuple{N}, Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector{&lt;:Point{Meshes.ùîº{N}}}}} where N"><code>WhatsThePoint.orient_normals!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">orient_normals!(normals::AbstractVector{&lt;:AbstractVector}, points::AbstractVector{&lt;:Point{ùîº{N}}}; k::Int=5) where {N}</code></pre><p>Correct the orientation of normals on a surface as the <a href="#WhatsThePoint.compute_normals-Union{Tuple{C}, Tuple{N}, Tuple{KNearestSearch, PointSurface{Meshes.ùîº{N}, C}}} where {N, C&lt;:CoordRefSystems.CRS}">compute_normals</a> function does not guarantee if the normal is inward or outward facing. Uses the approach from &quot;Surface Reconstruction from Unorganized Points&quot; - Hoppe (1992).</p><p>Requires Euclidean manifold (<code>ùîº{2}</code> or <code>ùîº{3}</code>). This function uses Euclidean dot products for orientation consistency.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.points-Tuple{PointBoundary}"><a class="docstring-binding" href="#WhatsThePoint.points-Tuple{PointBoundary}"><code>WhatsThePoint.points</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">points(boundary::PointBoundary)</code></pre><p>Return vector of all points from all surfaces in the boundary.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.points-Tuple{PointCloud}"><a class="docstring-binding" href="#WhatsThePoint.points-Tuple{PointCloud}"><code>WhatsThePoint.points</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">points(cloud::PointCloud)</code></pre><p>Return vector of all points (boundary + volume).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.points-Tuple{PointSurface}"><a class="docstring-binding" href="#WhatsThePoint.points-Tuple{PointSurface}"><code>WhatsThePoint.points</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">points(surf::PointSurface)</code></pre><p>Return vector of points from surface. Alias for <code>point(surf)</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.points-Tuple{PointVolume}"><a class="docstring-binding" href="#WhatsThePoint.points-Tuple{PointVolume}"><code>WhatsThePoint.points</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">points(vol::PointVolume)</code></pre><p>Return vector of points from volume.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.rebuild_topology!-Tuple{KNNTopology, Any}"><a class="docstring-binding" href="#WhatsThePoint.rebuild_topology!-Tuple{KNNTopology, Any}"><code>WhatsThePoint.rebuild_topology!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rebuild_topology!(topo::KNNTopology, points)</code></pre><p>Rebuild k-nearest neighbor topology in place.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.rebuild_topology!-Tuple{NoTopology, Any}"><a class="docstring-binding" href="#WhatsThePoint.rebuild_topology!-Tuple{NoTopology, Any}"><code>WhatsThePoint.rebuild_topology!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rebuild_topology!(topo::NoTopology, points)</code></pre><p>No-op for NoTopology (nothing to rebuild).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.rebuild_topology!-Tuple{PointCloud}"><a class="docstring-binding" href="#WhatsThePoint.rebuild_topology!-Tuple{PointCloud}"><code>WhatsThePoint.rebuild_topology!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rebuild_topology!(cloud::PointCloud)</code></pre><p>Rebuild topology in place using same parameters. No-op if NoTopology.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.rebuild_topology!-Tuple{PointSurface}"><a class="docstring-binding" href="#WhatsThePoint.rebuild_topology!-Tuple{PointSurface}"><code>WhatsThePoint.rebuild_topology!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rebuild_topology!(surf::PointSurface)</code></pre><p>Rebuild topology in place using same parameters. No-op if NoTopology.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.rebuild_topology!-Tuple{PointVolume}"><a class="docstring-binding" href="#WhatsThePoint.rebuild_topology!-Tuple{PointVolume}"><code>WhatsThePoint.rebuild_topology!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rebuild_topology!(vol::PointVolume)</code></pre><p>Rebuild topology in place using same parameters. No-op if NoTopology.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.rebuild_topology!-Tuple{RadiusTopology, Any}"><a class="docstring-binding" href="#WhatsThePoint.rebuild_topology!-Tuple{RadiusTopology, Any}"><code>WhatsThePoint.rebuild_topology!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rebuild_topology!(topo::RadiusTopology, points)</code></pre><p>Rebuild radius-based topology in place.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.repel-Union{Tuple{C}, Tuple{N}, Tuple{PointCloud{Meshes.ùîº{N}, C}, Any}} where {N, C&lt;:CoordRefSystems.CRS}"><a class="docstring-binding" href="#WhatsThePoint.repel-Union{Tuple{C}, Tuple{N}, Tuple{PointCloud{Meshes.ùîº{N}, C}, Any}} where {N, C&lt;:CoordRefSystems.CRS}"><code>WhatsThePoint.repel</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">repel(cloud::PointCloud, spacing; Œ≤=0.2, Œ±=auto, k=21, max_iters=1000, tol=1e-6)</code></pre><p>Optimize point distribution via node repulsion (Miotti 2023). Returns <code>(new_cloud, convergence_vector)</code> tuple.</p><p>The returned cloud has <code>NoTopology</code> since points have moved.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.set_topology-Tuple{PointCloud, Type{KNNTopology}, Int64}"><a class="docstring-binding" href="#WhatsThePoint.set_topology-Tuple{PointCloud, Type{KNNTopology}, Int64}"><code>WhatsThePoint.set_topology</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_topology(cloud::PointCloud, ::Type{KNNTopology}, k::Int)</code></pre><p>Build and return new cloud with k-nearest neighbor topology.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.set_topology-Tuple{PointCloud, Type{RadiusTopology}, Any}"><a class="docstring-binding" href="#WhatsThePoint.set_topology-Tuple{PointCloud, Type{RadiusTopology}, Any}"><code>WhatsThePoint.set_topology</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_topology(cloud::PointCloud, ::Type{RadiusTopology}, radius)</code></pre><p>Build and return new cloud with radius-based topology.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.set_topology-Tuple{PointSurface, Type{KNNTopology}, Int64}"><a class="docstring-binding" href="#WhatsThePoint.set_topology-Tuple{PointSurface, Type{KNNTopology}, Int64}"><code>WhatsThePoint.set_topology</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_topology(surf::PointSurface, ::Type{KNNTopology}, k::Int)</code></pre><p>Build and return new surface with k-nearest neighbor topology.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.set_topology-Tuple{PointSurface, Type{RadiusTopology}, Any}"><a class="docstring-binding" href="#WhatsThePoint.set_topology-Tuple{PointSurface, Type{RadiusTopology}, Any}"><code>WhatsThePoint.set_topology</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_topology(surf::PointSurface, ::Type{RadiusTopology}, radius)</code></pre><p>Build and return new surface with radius-based topology.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.set_topology-Tuple{PointVolume, Type{KNNTopology}, Int64}"><a class="docstring-binding" href="#WhatsThePoint.set_topology-Tuple{PointVolume, Type{KNNTopology}, Int64}"><code>WhatsThePoint.set_topology</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_topology(vol::PointVolume, ::Type{KNNTopology}, k::Int)</code></pre><p>Build and return new volume with k-nearest neighbor topology.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.set_topology-Tuple{PointVolume, Type{RadiusTopology}, Any}"><a class="docstring-binding" href="#WhatsThePoint.set_topology-Tuple{PointVolume, Type{RadiusTopology}, Any}"><code>WhatsThePoint.set_topology</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_topology(vol::PointVolume, ::Type{RadiusTopology}, radius)</code></pre><p>Build and return new volume with radius-based topology.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.topology-Tuple{PointCloud}"><a class="docstring-binding" href="#WhatsThePoint.topology-Tuple{PointCloud}"><code>WhatsThePoint.topology</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">topology(cloud::PointCloud)</code></pre><p>Return the topology of the point cloud.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.topology-Tuple{PointSurface}"><a class="docstring-binding" href="#WhatsThePoint.topology-Tuple{PointSurface}"><code>WhatsThePoint.topology</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">topology(surf::PointSurface)</code></pre><p>Return the topology of the surface.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.topology-Tuple{PointVolume}"><a class="docstring-binding" href="#WhatsThePoint.topology-Tuple{PointVolume}"><code>WhatsThePoint.topology</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">topology(vol::PointVolume)</code></pre><p>Return the topology of the volume.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.update_normals!-Union{Tuple{PointSurface{Meshes.ùîº{N}, C}}, Tuple{C}, Tuple{N}} where {N, C&lt;:CoordRefSystems.CRS}"><a class="docstring-binding" href="#WhatsThePoint.update_normals!-Union{Tuple{PointSurface{Meshes.ùîº{N}, C}}, Tuple{C}, Tuple{N}} where {N, C&lt;:CoordRefSystems.CRS}"><code>WhatsThePoint.update_normals!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_normals!(surf::PointSurface{ùîº{N},C}; k::Int=5) where {N,C&lt;:CRS}</code></pre><p>Update the normals of the boundary of a surf. This is necessary whenever the points change for any reason.</p><p>Requires Euclidean manifold (<code>ùîº{2}</code> or <code>ùîº{3}</code>). This function assumes flat space geometry.</p></div></section></details></article><h2 id="Private"><a class="docs-heading-anchor" href="#Private">Private</a><a id="Private-1"></a><a class="docs-heading-anchor-permalink" href="#Private" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="WhatsThePoint.AbstractOctree"><a class="docstring-binding" href="#WhatsThePoint.AbstractOctree"><code>WhatsThePoint.AbstractOctree</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractOctree{E,T} = AbstractSpatialTree{3,E,T}</code></pre><p>Convenience alias for 3D spatial trees (octrees).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.AbstractSpatialTree"><a class="docstring-binding" href="#WhatsThePoint.AbstractSpatialTree"><code>WhatsThePoint.AbstractSpatialTree</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractSpatialTree{N,E,T}</code></pre><p>Abstract type for N-dimensional spatial trees.</p><p><strong>Type Parameters</strong></p><ul><li><code>N::Int</code>: Spatial dimensionality (2 for quadtree, 3 for octree)</li><li><code>E</code>: Element type stored in tree (e.g., Int for indices)</li><li><code>T&lt;:Real</code>: Coordinate numeric type (Float64, Float32, etc.)</li></ul><p><strong>Interface Requirements</strong></p><p>Trees must implement:</p><ul><li><code>find_leaf(tree, point)</code> - Locate leaf containing point</li><li><code>bounding_box(tree)</code> - Get overall bounds</li><li><code>num_elements(tree)</code> - Total elements stored</li></ul><p>Optional:</p><ul><li><code>find_neighbors(tree, box_idx, direction)</code> - Neighbor queries</li><li><code>balance!(tree)</code> - Enforce refinement constraints</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.AndCriterion"><a class="docstring-binding" href="#WhatsThePoint.AndCriterion"><code>WhatsThePoint.AndCriterion</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AndCriterion{T&lt;:Tuple} &lt;: SubdivisionCriterion</code></pre><p>Combine multiple criteria - all must be satisfied for subdivision.</p><p><strong>Fields</strong></p><ul><li><code>criteria::T</code>: Tuple of criteria to combine (parametrized for type stability)</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.MaxElementsCriterion"><a class="docstring-binding" href="#WhatsThePoint.MaxElementsCriterion"><code>WhatsThePoint.MaxElementsCriterion</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MaxElementsCriterion &lt;: SubdivisionCriterion</code></pre><p>Subdivide box if number of elements exceeds threshold.</p><p><strong>Fields</strong></p><ul><li><code>max_elements::Int</code>: Maximum elements before subdivision</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.NearestTriangleState"><a class="docstring-binding" href="#WhatsThePoint.NearestTriangleState"><code>WhatsThePoint.NearestTriangleState</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NearestTriangleState{T&lt;:Real}</code></pre><p>Mutable state for nearest-triangle search, replacing 3 separate <code>Ref</code> allocations with a single struct (1 heap allocation instead of 3, enables potential SROA).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.SizeCriterion"><a class="docstring-binding" href="#WhatsThePoint.SizeCriterion"><code>WhatsThePoint.SizeCriterion</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SizeCriterion{T&lt;:Real} &lt;: SubdivisionCriterion</code></pre><p>Subdivide box if size exceeds threshold.</p><p><strong>Fields</strong></p><ul><li><code>h_min::T</code>: Minimum box size (stop subdividing when reached)</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.SpatialOctree"><a class="docstring-binding" href="#WhatsThePoint.SpatialOctree"><code>WhatsThePoint.SpatialOctree</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SpatialOctree{E,T&lt;:Real} &lt;: AbstractOctree{E,T}</code></pre><p>Concrete octree implementation using integer coordinate system for efficient neighbor finding.</p><p>Uses (i,j,k,N) coordinate system where:</p><ul><li>(i,j,k) are integer coordinates at refinement level N</li><li>Box center = origin + (2*[i,j,k] + 1) * (root_size / N) / 2</li><li>Enables O(1) neighbor calculation from coordinates</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>E</code>: Type of elements stored (e.g., Int for triangle IDs)</li><li><code>T</code>: Coordinate numeric type (e.g., Float64, Float32)</li></ul><p><strong>Fields</strong></p><ul><li><code>parent::Vector{Int}</code>: Parent box index for each node (0 = root has no parent)</li><li><code>children::Vector{SVector{8,Int}}</code>: 8 child indices per box (0 = no child)</li><li><code>coords::Vector{SVector{4,Int}}</code>: (i,j,k,N) coordinates per box where N is refinement level</li><li><code>origin::SVector{3,T}</code>: Spatial origin of root box</li><li><code>root_size::T</code>: Size of root box (assumed cubic)</li><li><code>element_lists::Vector{Vector{E}}</code>: Elements in each box</li><li><code>num_boxes::Ref{Int}</code>: Current number of boxes (mutable counter)</li></ul><p><strong>Interface Implementation</strong></p><p>Implements <code>AbstractSpatialTree</code> interface:</p><ul><li><code>find_leaf(tree, point)</code> - O(log n) point location</li><li><code>bounding_box(tree)</code> - Root box bounds</li><li><code>num_elements(tree)</code> - Total stored elements</li><li><code>find_neighbor(tree, box, dir)</code> - 6-directional neighbor finding</li><li><code>balance_octree!(tree)</code> - 2:1 refinement constraint</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using StaticArrays

origin = SVector(0.0, 0.0, 0.0)
octree = SpatialOctree{Int,Float64}(origin, 10.0)

# Subdivide root
subdivide!(octree, 1)

# Find leaf containing point
point = SVector(2.0, 2.0, 2.0)
leaf = find_leaf(octree, point)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.SpatialOctree-Union{Tuple{T}, Tuple{E}, Tuple{StaticArraysCore.SVector{3, T}, T}} where {E, T}"><a class="docstring-binding" href="#WhatsThePoint.SpatialOctree-Union{Tuple{T}, Tuple{E}, Tuple{StaticArraysCore.SVector{3, T}, T}} where {E, T}"><code>WhatsThePoint.SpatialOctree</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SpatialOctree{E,T}(origin::SVector{3,T}, size::T; initial_capacity=1000)</code></pre><p>Create empty octree with root node.</p><p><strong>Arguments</strong></p><ul><li><code>origin</code>: Minimum corner of root box</li><li><code>size</code>: Edge length of root box (assumed cubic)</li><li><code>initial_capacity</code>: Initial array capacity (will grow as needed)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">origin = SVector(0.0, 0.0, 0.0)
octree = SpatialOctree{Int,Float64}(origin, 10.0)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.SubdivisionCriterion"><a class="docstring-binding" href="#WhatsThePoint.SubdivisionCriterion"><code>WhatsThePoint.SubdivisionCriterion</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SubdivisionCriterion</code></pre><p>Abstract type for subdivision decision logic.</p><p>Allows pluggable subdivision criteria via dispatch.</p><p><strong>Built-in Criteria</strong></p><ul><li><code>MaxElementsCriterion(max_elements)</code> - Subdivide if too many elements</li><li><code>SizeCriterion(h_min)</code> - Subdivide until box small enough</li><li><code>AndCriterion(criteria...)</code> - All criteria must be satisfied</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">criterion = AndCriterion((
    MaxElementsCriterion(50),
    SizeCriterion(0.1)
))</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="Base.filter-Tuple{Function, PointVolume}"><a class="docstring-binding" href="#Base.filter-Tuple{Function, PointVolume}"><code>Base.filter</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">filter(f::Function, vol::PointVolume)</code></pre><p>Return new PointVolume with only points satisfying predicate <code>f</code>. Topology is stripped since point indices change.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="Base.isvalid-Tuple{Union{KNNTopology, RadiusTopology}}"><a class="docstring-binding" href="#Base.isvalid-Tuple{Union{KNNTopology, RadiusTopology}}"><code>Base.isvalid</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isvalid(t::AbstractTopology)</code></pre><p>Check if topology is valid. With immutable design, topology is always valid if it exists.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._allocate_counts_by_volume-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Real"><a class="docstring-binding" href="#WhatsThePoint._allocate_counts_by_volume-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Real"><code>WhatsThePoint._allocate_counts_by_volume</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_allocate_counts_by_volume(volumes, total_count; ensure_one=false)</code></pre><p>Allocate integer counts across leaves proportionally to <code>volumes</code> using largest-remainder rounding, preserving exact total count.</p><p>If <code>ensure_one=true</code> and <code>total_count &gt;= length(volumes)</code>, each leaf gets at least one allocation before distributing the remainder by volume.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._auto_h_min-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh}} where T"><a class="docstring-binding" href="#WhatsThePoint._auto_h_min-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh}} where T"><code>WhatsThePoint._auto_h_min</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_auto_h_min(::Type{T}, mesh::SimpleMesh) where {T}</code></pre><p>Compute a default <code>h_min</code> for octree construction based on mesh geometry.</p><p>Heuristic: <code>bbox_diagonal / (2 * cbrt(n_triangles))</code>. Scales leaf size to the mesh&#39;s characteristic triangle spacing so the octree resolves surface detail without excessive subdivision.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._build_knn_neighbors-Tuple{Any, Int64}"><a class="docstring-binding" href="#WhatsThePoint._build_knn_neighbors-Tuple{Any, Int64}"><code>WhatsThePoint._build_knn_neighbors</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_build_knn_neighbors(points, k::Int) -&gt; Vector{Vector{Int}}</code></pre><p>Build k-nearest neighbor adjacency list from points.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._build_radius_neighbors-Tuple{Any, Any}"><a class="docstring-binding" href="#WhatsThePoint._build_radius_neighbors-Tuple{Any, Any}"><code>WhatsThePoint._build_radius_neighbors</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_build_radius_neighbors(points, radius) -&gt; Vector{Vector{Int}}</code></pre><p>Build radius-based adjacency list from points.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._classify_empty_leaf_conservative-Union{Tuple{T}, Tuple{WhatsThePoint.SpatialOctree{Int64, T}, Meshes.SimpleMesh, Int64}} where T&lt;:Real"><a class="docstring-binding" href="#WhatsThePoint._classify_empty_leaf_conservative-Union{Tuple{T}, Tuple{WhatsThePoint.SpatialOctree{Int64, T}, Meshes.SimpleMesh, Int64}} where T&lt;:Real"><code>WhatsThePoint._classify_empty_leaf_conservative</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_classify_empty_leaf_conservative(tree, mesh, leaf_idx) -&gt; Int8</code></pre><p>Conservative classification for empty leaves.</p><ul><li><code>2</code> (interior): center and all 8 corners classify inside</li><li><code>0</code> (exterior): center and all 8 corners classify outside</li><li><code>1</code> (boundary): mixed results</li></ul><p>This avoids falsely labeling a partially-outside leaf as interior.</p><p>Implementation uses octree-accelerated signed distance, not ray casting.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._classify_leaves-Union{Tuple{T}, Tuple{WhatsThePoint.SpatialOctree{Int64, T}, Meshes.SimpleMesh}} where T&lt;:Real"><a class="docstring-binding" href="#WhatsThePoint._classify_leaves-Union{Tuple{T}, Tuple{WhatsThePoint.SpatialOctree{Int64, T}, Meshes.SimpleMesh}} where T&lt;:Real"><code>WhatsThePoint._classify_leaves</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_classify_leaves(tree::SpatialOctree{Int,T}, mesh::SimpleMesh) -&gt; Vector{Int8}</code></pre><p>Classify octree leaves as exterior (0), boundary (1), or interior (2).</p><p>Uses octree-accelerated signed distance for robust classification.</p><p><strong>Returns</strong></p><ul><li><code>classification::Vector{Int8}</code>: Classification for each box<ul><li><code>-1</code>: Internal node (not a leaf, unclassified)</li><li><code>0</code>: Exterior leaf</li><li><code>1</code>: Boundary leaf</li><li><code>2</code>: Interior leaf</li></ul></li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._collect_classified_leaves-Tuple{TriangleOctree}"><a class="docstring-binding" href="#WhatsThePoint._collect_classified_leaves-Tuple{TriangleOctree}"><code>WhatsThePoint._collect_classified_leaves</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_collect_classified_leaves(octree::TriangleOctree)</code></pre><p>Collect interior and boundary leaves with their volumes from a classified octree.</p><p>Returns <code>(interior_leaves, interior_volumes, boundary_leaves, boundary_volumes)</code>.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._compute_bbox-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh}} where T"><a class="docstring-binding" href="#WhatsThePoint._compute_bbox-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh}} where T"><code>WhatsThePoint._compute_bbox</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_compute_bbox(::Type{T}, mesh::SimpleMesh) where {T} -&gt; (bbox_min, bbox_max)</code></pre><p>Compute bounding box from mesh triangle data.</p><p>Performance: Single-pass min/max accumulation over all triangles.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._compute_local_signed_distance-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, Meshes.SimpleMesh, Vector{Int64}}} where T&lt;:Real"><a class="docstring-binding" href="#WhatsThePoint._compute_local_signed_distance-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, Meshes.SimpleMesh, Vector{Int64}}} where T&lt;:Real"><code>WhatsThePoint._compute_local_signed_distance</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_compute_local_signed_distance(
    point::SVector{3,T},
    mesh::SimpleMesh,
    tri_indices::Vector{Int}
) -&gt; T</code></pre><p>Compute signed distance from point to nearest triangle in the local set.</p><p>This is the key performance optimization: instead of checking all M triangles, we only check the k‚âà10-50 triangles in the point&#39;s octree leaf.</p><p>Performance: Fused computation avoids redundant closest_point calculation.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._compute_signed_distance_octree-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, Meshes.SimpleMesh, WhatsThePoint.SpatialOctree{Int64, T}}} where T&lt;:Real"><a class="docstring-binding" href="#WhatsThePoint._compute_signed_distance_octree-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, Meshes.SimpleMesh, WhatsThePoint.SpatialOctree{Int64, T}}} where T&lt;:Real"><code>WhatsThePoint._compute_signed_distance_octree</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_compute_signed_distance_octree(point, mesh, tree) -&gt; T</code></pre><p>Compute signed distance to the closest triangle using octree branch-and-bound.</p><p>This avoids global O(M) triangle scans by searching only relevant octree regions.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._create_root_octree-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh, Int64}} where T"><a class="docstring-binding" href="#WhatsThePoint._create_root_octree-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh, Int64}} where T"><code>WhatsThePoint._create_root_octree</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_create_root_octree(::Type{T}, mesh::SimpleMesh, n_triangles::Int) where {T} -&gt; SpatialOctree{Int,T}</code></pre><p>Create root octree covering mesh bounding box with all triangles in root.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._edge_key-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T"><a class="docstring-binding" href="#WhatsThePoint._edge_key-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where T"><code>WhatsThePoint._edge_key</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_edge_key(v1::SVector{3,T}, v2::SVector{3,T}) where {T} -&gt; Tuple</code></pre><p>Create a canonical edge key from two vertices (order-independent). Uses component-wise comparison for consistent ordering.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._extract_vertex-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#WhatsThePoint._extract_vertex-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>WhatsThePoint._extract_vertex</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_extract_vertex(::Type{T}, vert) where {T} -&gt; SVector{3,T}</code></pre><p>Extract coordinates from a Meshes.jl vertex to an SVector{3,T}.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._get_triangle_normal-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh, Int64}} where T"><a class="docstring-binding" href="#WhatsThePoint._get_triangle_normal-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh, Int64}} where T"><code>WhatsThePoint._get_triangle_normal</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_triangle_normal(::Type{T}, mesh::SimpleMesh, tri_idx::Int) where {T} -&gt; SVector{3,T}</code></pre><p>Extract and normalize triangle normal from mesh. Accesses mesh data on-the-fly.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._get_triangle_vertices-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh, Int64}} where T"><a class="docstring-binding" href="#WhatsThePoint._get_triangle_vertices-Union{Tuple{T}, Tuple{Type{T}, Meshes.SimpleMesh, Int64}} where T"><code>WhatsThePoint._get_triangle_vertices</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_triangle_vertices(::Type{T}, mesh::SimpleMesh, tri_idx::Int) where {T} -&gt; (SVector{3,T}, SVector{3,T}, SVector{3,T})</code></pre><p>Extract triangle vertices from mesh as SVectors. Accesses mesh data on-the-fly.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._normalize_normal-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#WhatsThePoint._normalize_normal-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>WhatsThePoint._normalize_normal</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_normalize_normal(::Type{T}, n_vec) where {T} -&gt; SVector{3,T}</code></pre><p>Extract and normalize a Meshes.jl Vec normal to a unit SVector{3,T}.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._subdivide_triangle_octree!-Union{Tuple{T}, Tuple{WhatsThePoint.SpatialOctree{Int64, T}, Meshes.SimpleMesh, Int64, WhatsThePoint.SubdivisionCriterion}} where T&lt;:Real"><a class="docstring-binding" href="#WhatsThePoint._subdivide_triangle_octree!-Union{Tuple{T}, Tuple{WhatsThePoint.SpatialOctree{Int64, T}, Meshes.SimpleMesh, Int64, WhatsThePoint.SubdivisionCriterion}} where T&lt;:Real"><code>WhatsThePoint._subdivide_triangle_octree!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_subdivide_triangle_octree!(tree, mesh, box_idx, criterion)</code></pre><p>Recursively subdivide a box in the triangle octree.</p><p>For each box that needs subdivision:</p><ol><li>Create 8 child boxes</li><li>For each triangle in parent, find which children it intersects</li><li>Distribute triangle indices to children</li><li>Recursively subdivide children if they meet criteria</li></ol></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint._triangle_axis_test-Union{Tuple{T}, NTuple{5, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><a class="docstring-binding" href="#WhatsThePoint._triangle_axis_test-Union{Tuple{T}, NTuple{5, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>WhatsThePoint._triangle_axis_test</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_triangle_axis_test(
    axis::SVector{3,T},
    v0::SVector{3,T},
    v1::SVector{3,T},
    v2::SVector{3,T},
    half::SVector{3,T}
) where {T&lt;:Real} -&gt; Bool</code></pre><p>Internal helper for triangle-box intersection separating axis test.</p><p>Tests if the projection intervals of the triangle vertices and box overlap along the given axis.</p><p><strong>Arguments</strong></p><ul><li><code>axis</code>: Separating axis direction</li><li><code>v0, v1, v2</code>: Triangle vertices in box-centered coordinates</li><li><code>half</code>: Box half-extents</li></ul><p><strong>Returns</strong></p><p><code>true</code> if intervals overlap (potential intersection), <code>false</code> if separated</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.add_box!-Union{Tuple{E}, Tuple{WhatsThePoint.SpatialOctree{E}, Vararg{Int64, 5}}} where E"><a class="docstring-binding" href="#WhatsThePoint.add_box!-Union{Tuple{E}, Tuple{WhatsThePoint.SpatialOctree{E}, Vararg{Int64, 5}}} where E"><code>WhatsThePoint.add_box!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_box!(octree::SpatialOctree, i::Int, j::Int, k::Int, N::Int, parent_idx::Int) -&gt; Int</code></pre><p>Add new box to octree. Returns box index.</p><p>Automatically grows arrays if capacity exceeded.</p><p><strong>Arguments</strong></p><ul><li><code>i, j, k</code>: Integer coordinates at level N</li><li><code>N</code>: Refinement level (N=1 is root, N=2 is first subdivision, etc.)</li><li><code>parent_idx</code>: Index of parent box</li></ul><p><strong>Returns</strong></p><p>Index of newly created box</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.all_boxes-Tuple{WhatsThePoint.SpatialOctree}"><a class="docstring-binding" href="#WhatsThePoint.all_boxes-Tuple{WhatsThePoint.SpatialOctree}"><code>WhatsThePoint.all_boxes</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">all_boxes(octree::SpatialOctree) -&gt; Vector{Int}</code></pre><p>Return indices of all boxes (leaves and internal nodes).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.all_leaves-Tuple{WhatsThePoint.SpatialOctree}"><a class="docstring-binding" href="#WhatsThePoint.all_leaves-Tuple{WhatsThePoint.SpatialOctree}"><code>WhatsThePoint.all_leaves</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">all_leaves(octree::SpatialOctree) -&gt; Vector{Int}</code></pre><p>Return indices of all leaf boxes.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.balance_octree!-Tuple{WhatsThePoint.SpatialOctree, WhatsThePoint.SubdivisionCriterion}"><a class="docstring-binding" href="#WhatsThePoint.balance_octree!-Tuple{WhatsThePoint.SpatialOctree, WhatsThePoint.SubdivisionCriterion}"><code>WhatsThePoint.balance_octree!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">balance_octree!(octree::SpatialOctree, criterion::SubdivisionCriterion)</code></pre><p>Enforce 2:1 balance constraint across entire octree.</p><p>Iteratively subdivides boxes that violate the 2:1 constraint until all adjacent boxes differ by at most one refinement level.</p><p><strong>Arguments</strong></p><ul><li><code>criterion</code>: Subdivision criterion (only size constraints are enforced)</li></ul><p><strong>Algorithm</strong></p><ol><li>Collect all leaves</li><li>Check each leaf for balance violations</li><li>Subdivide violating neighbors (only respecting physical limits like h_min)</li><li>Repeat until no violations</li></ol><p><strong>Note</strong></p><ul><li>Uses <code>can_subdivide</code> (not <code>should_subdivide</code>) to ignore element count criteria</li><li>Balancing is a geometric constraint, not an optimization decision</li><li>Maximum iterations limit prevents infinite loops. If hit, tree may not be fully balanced.</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.bounding_box-Union{Tuple{WhatsThePoint.SpatialOctree{E, T}}, Tuple{T}, Tuple{E}} where {E, T}"><a class="docstring-binding" href="#WhatsThePoint.bounding_box-Union{Tuple{WhatsThePoint.SpatialOctree{E, T}}, Tuple{T}, Tuple{E}} where {E, T}"><code>WhatsThePoint.bounding_box</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bounding_box(octree::SpatialOctree) -&gt; (SVector{3}, SVector{3})</code></pre><p>Get overall bounding box of tree (root box).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.box_bounds-Union{Tuple{T}, Tuple{E}, Tuple{WhatsThePoint.SpatialOctree{E, T}, Int64}} where {E, T}"><a class="docstring-binding" href="#WhatsThePoint.box_bounds-Union{Tuple{T}, Tuple{E}, Tuple{WhatsThePoint.SpatialOctree{E, T}, Int64}} where {E, T}"><code>WhatsThePoint.box_bounds</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">box_bounds(octree::SpatialOctree, box_idx::Int) -&gt; (SVector{3}, SVector{3})</code></pre><p>Get (min<em>corner, max</em>corner) of box.</p><p><strong>Returns</strong></p><p>Tuple of (min<em>corner, max</em>corner) as SVector{3,C}</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.box_center-Union{Tuple{T}, Tuple{E}, Tuple{WhatsThePoint.SpatialOctree{E, T}, Int64}} where {E, T}"><a class="docstring-binding" href="#WhatsThePoint.box_center-Union{Tuple{T}, Tuple{E}, Tuple{WhatsThePoint.SpatialOctree{E, T}, Int64}} where {E, T}"><code>WhatsThePoint.box_center</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">box_center(octree::SpatialOctree, box_idx::Int) -&gt; SVector{3}</code></pre><p>Compute spatial center of box using (i,j,k,N) coordinates.</p><p><strong>Formula</strong></p><pre><code class="language-julia hljs">center = origin + (2*[i,j,k] + 1) * box_size / 2</code></pre><p>where <code>box_size = root_size / N</code></p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.box_size"><a class="docstring-binding" href="#WhatsThePoint.box_size"><code>WhatsThePoint.box_size</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">box_size(tree::AbstractSpatialTree, box_idx::Int) -&gt; Real</code></pre><p>Get edge length of box.</p><p><strong>Required</strong></p><p>Trees must implement this function.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.box_size-Tuple{WhatsThePoint.SpatialOctree, Int64}"><a class="docstring-binding" href="#WhatsThePoint.box_size-Tuple{WhatsThePoint.SpatialOctree, Int64}"><code>WhatsThePoint.box_size</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">box_size(octree::SpatialOctree, box_idx::Int) -&gt; Real</code></pre><p>Get edge length of box.</p><p>Box size at refinement level N is: <code>root_size / N</code></p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.can_subdivide"><a class="docstring-binding" href="#WhatsThePoint.can_subdivide"><code>WhatsThePoint.can_subdivide</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">can_subdivide(criterion::SubdivisionCriterion, tree, box_idx) -&gt; Bool</code></pre><p>Check if box CAN be subdivided based on physical constraints only.</p><p>Unlike <code>should_subdivide</code>, this ignores content-based criteria (like element count) and only checks physical limits (like minimum size). Used during balancing where subdivision is required for geometric correctness, not optimization.</p><p><strong>Arguments</strong></p><ul><li><code>criterion</code>: Subdivision criterion (only size constraints are checked)</li><li><code>tree</code>: Spatial tree</li><li><code>box_idx</code>: Index of box to check</li></ul><p><strong>Returns</strong></p><p><code>true</code> if box can physically be subdivided, <code>false</code> if at minimum size limit.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># For balancing, we only respect size limits
if needs_balancing(leaf)
    if can_subdivide(criterion, tree, leaf)
        subdivide!(tree, leaf)
    end
end</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.closest_point_on_triangle-Union{Tuple{T}, NTuple{4, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><a class="docstring-binding" href="#WhatsThePoint.closest_point_on_triangle-Union{Tuple{T}, NTuple{4, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>WhatsThePoint.closest_point_on_triangle</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">closest_point_on_triangle(
    P::SVector{3,T},
    v1::SVector{3,T},
    v2::SVector{3,T},
    v3::SVector{3,T}
) where {T&lt;:Real} -&gt; SVector{3,T}</code></pre><p>Compute the closest point on triangle (v1, v2, v3) to point P.</p><p>Uses barycentric coordinate method from Ericson&#39;s &quot;Real-Time Collision Detection&quot;. The closest point is computed by:</p><ol><li>Projecting P onto the triangle plane</li><li>Computing barycentric coordinates</li><li>Clamping to triangle if outside</li></ol><p><strong>Algorithm</strong></p><p>The triangle can be parameterized as:     T(u,v) = v1 + u<em>(v2-v1) + v</em>(v3-v1)  for u,v ‚â• 0, u+v ‚â§ 1</p><p>We find the closest point by solving a constrained minimization problem.</p><p><strong>Returns</strong></p><p>Point on triangle surface closest to P (may be on edge or vertex).</p><p><strong>References</strong></p><p>Ericson, &quot;Real-Time Collision Detection&quot;, Chapter 5.1.5</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.distance_point_triangle-Union{Tuple{T}, NTuple{4, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><a class="docstring-binding" href="#WhatsThePoint.distance_point_triangle-Union{Tuple{T}, NTuple{4, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>WhatsThePoint.distance_point_triangle</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">distance_point_triangle(
    P::SVector{3,T},
    v1::SVector{3,T},
    v2::SVector{3,T},
    v3::SVector{3,T}
) where {T&lt;:Real} -&gt; T</code></pre><p>Compute unsigned distance from point P to triangle (v1, v2, v3).</p><p><strong>Returns</strong></p><p>Unsigned distance (always positive or zero)</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.distance_point_triangle-Union{Tuple{T}, NTuple{5, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><a class="docstring-binding" href="#WhatsThePoint.distance_point_triangle-Union{Tuple{T}, NTuple{5, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>WhatsThePoint.distance_point_triangle</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">distance_point_triangle(
    P::SVector{3,T},
    v1::SVector{3,T},
    v2::SVector{3,T},
    v3::SVector{3,T},
    normal::SVector{3,T}
) where {T&lt;:Real} -&gt; T</code></pre><p>Compute signed distance from point P to triangle (v1, v2, v3).</p><p>The distance is:</p><ul><li><strong>Positive</strong> if P is on the side of the triangle that the normal points to</li><li><strong>Negative</strong> if P is on the opposite side</li><li><strong>Zero</strong> if P is on the triangle plane</li></ul><p><strong>Algorithm</strong></p><ol><li>Find closest point Q on triangle to P</li><li>Compute distance ||P - Q||</li><li>Determine sign based on which side of triangle P is on</li></ol><p><strong>Arguments</strong></p><ul><li><code>P</code>: Query point</li><li><code>v1, v2, v3</code>: Triangle vertices in counterclockwise order</li><li><code>normal</code>: Outward-pointing unit normal vector</li></ul><p><strong>Returns</strong></p><p>Signed distance (positive = outside, negative = inside for closed surface)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using StaticArrays

# Triangle in xy-plane
v1 = SVector(0.0, 0.0, 0.0)
v2 = SVector(1.0, 0.0, 0.0)
v3 = SVector(0.0, 1.0, 0.0)
normal = SVector(0.0, 0.0, 1.0)

# Point above triangle
P = SVector(0.25, 0.25, 1.0)
d = distance_point_triangle(P, v1, v2, v3, normal)
# d ‚âà 1.0 (positive, on normal side)</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.find_boxes_at_coords-Tuple{WhatsThePoint.SpatialOctree, Vararg{Int64, 4}}"><a class="docstring-binding" href="#WhatsThePoint.find_boxes_at_coords-Tuple{WhatsThePoint.SpatialOctree, Vararg{Int64, 4}}"><code>WhatsThePoint.find_boxes_at_coords</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_boxes_at_coords(octree::SpatialOctree, i_target::Int, j_target::Int, k_target::Int, N_target::Int) -&gt; Vector{Int}</code></pre><p>Find box(es) at given (i,j,k,N) coordinates.</p><ul><li>If exact match found at level N<em>target, returns [box</em>idx]</li><li>If location is covered by coarser box, returns [coarser<em>box</em>idx]</li><li>If location is subdivided finer, returns all descendants at that location</li></ul><p><strong>Returns</strong></p><p>Vector of box indices covering the target location</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.find_leaf-Union{Tuple{T}, Tuple{E}, Tuple{WhatsThePoint.SpatialOctree{E, T}, StaticArraysCore.SVector{3, T}}} where {E, T}"><a class="docstring-binding" href="#WhatsThePoint.find_leaf-Union{Tuple{T}, Tuple{E}, Tuple{WhatsThePoint.SpatialOctree{E, T}, StaticArraysCore.SVector{3, T}}} where {E, T}"><code>WhatsThePoint.find_leaf</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_leaf(octree::SpatialOctree, point::SVector{3}) -&gt; Int</code></pre><p>Find leaf box containing point. Returns box index.</p><p>Traverses tree from root to leaf in O(log n) time.</p><p><strong>Arguments</strong></p><ul><li><code>point</code>: Query point in same coordinate system as octree</li></ul><p><strong>Returns</strong></p><p>Index of leaf box containing point</p><p><strong>Throws</strong></p><p>AssertionError if point is outside octree bounds</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.find_neighbor-Tuple{WhatsThePoint.SpatialOctree, Int64, Int64}"><a class="docstring-binding" href="#WhatsThePoint.find_neighbor-Tuple{WhatsThePoint.SpatialOctree, Int64, Int64}"><code>WhatsThePoint.find_neighbor</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_neighbor(octree::SpatialOctree, box_idx::Int, direction::Int) -&gt; Vector{Int}</code></pre><p>Find neighbor(s) in given direction. Returns vector of neighbor indices.</p><p>Handles 2:1 refinement level difference:</p><ul><li>If neighbor exists at same level: returns [neighbor_idx]</li><li>If neighbor is subdivided (finer): returns children on shared face (up to 4)</li><li>If neighbor doesn&#39;t exist (boundary): returns empty vector</li></ul><p><strong>Arguments</strong></p><ul><li><code>box_idx</code>: Box to find neighbor of</li><li><code>direction</code>: Direction code (1-6, see <code>neighbor_direction</code>)</li></ul><p><strong>Returns</strong></p><p>Vector of neighbor box indices (may be empty if at boundary)</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.has_children"><a class="docstring-binding" href="#WhatsThePoint.has_children"><code>WhatsThePoint.has_children</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_children(tree::AbstractSpatialTree, box_idx::Int) -&gt; Bool</code></pre><p>Check if box has been subdivided.</p><p><strong>Required</strong></p><p>Trees must implement this function.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.has_children-Tuple{WhatsThePoint.SpatialOctree, Int64}"><a class="docstring-binding" href="#WhatsThePoint.has_children-Tuple{WhatsThePoint.SpatialOctree, Int64}"><code>WhatsThePoint.has_children</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_children(octree::SpatialOctree, box_idx::Int) -&gt; Bool</code></pre><p>Check if box has been subdivided.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.is_leaf"><a class="docstring-binding" href="#WhatsThePoint.is_leaf"><code>WhatsThePoint.is_leaf</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_leaf(tree::AbstractSpatialTree, box_idx::Int) -&gt; Bool</code></pre><p>Check if box is a leaf (has no children).</p><p><strong>Required</strong></p><p>Trees must implement this function.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.is_leaf-Tuple{WhatsThePoint.SpatialOctree, Int64}"><a class="docstring-binding" href="#WhatsThePoint.is_leaf-Tuple{WhatsThePoint.SpatialOctree, Int64}"><code>WhatsThePoint.is_leaf</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_leaf(octree::SpatialOctree, box_idx::Int) -&gt; Bool</code></pre><p>Check if box has no children.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.needs_balancing-Tuple{WhatsThePoint.SpatialOctree, Int64}"><a class="docstring-binding" href="#WhatsThePoint.needs_balancing-Tuple{WhatsThePoint.SpatialOctree, Int64}"><code>WhatsThePoint.needs_balancing</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">needs_balancing(octree::SpatialOctree, box_idx::Int) -&gt; Bool</code></pre><p>Check if subdividing this box would violate 2:1 balance with any neighbor.</p><p>Returns true if any neighbor has grandchildren (2-level refinement difference).</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.neighbor_direction-Tuple{Int64}"><a class="docstring-binding" href="#WhatsThePoint.neighbor_direction-Tuple{Int64}"><code>WhatsThePoint.neighbor_direction</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neighbor_direction(direction::Int) -&gt; (Int, Int, Int)</code></pre><p>Convert direction code to (di, dj, dk) offset.</p><p><strong>Direction Codes</strong></p><ul><li>1: -x (left)</li><li>2: +x (right)</li><li>3: -y (bottom)</li><li>4: +y (top)</li><li>5: -z (front)</li><li>6: +z (back)</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.num_elements-Tuple{WhatsThePoint.SpatialOctree}"><a class="docstring-binding" href="#WhatsThePoint.num_elements-Tuple{WhatsThePoint.SpatialOctree}"><code>WhatsThePoint.num_elements</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">num_elements(octree::SpatialOctree) -&gt; Int</code></pre><p>Total number of elements stored in tree.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.should_subdivide"><a class="docstring-binding" href="#WhatsThePoint.should_subdivide"><code>WhatsThePoint.should_subdivide</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">should_subdivide(criterion::SubdivisionCriterion, tree, box_idx) -&gt; Bool</code></pre><p>Determine if box should be subdivided based on criterion.</p><p><strong>Arguments</strong></p><ul><li><code>criterion</code>: Subdivision criterion to evaluate</li><li><code>tree</code>: Spatial tree</li><li><code>box_idx</code>: Index of box to check</li></ul><p><strong>Returns</strong></p><p><code>true</code> if box should be subdivided, <code>false</code> otherwise.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.subdivide!-Tuple{WhatsThePoint.SpatialOctree, Int64}"><a class="docstring-binding" href="#WhatsThePoint.subdivide!-Tuple{WhatsThePoint.SpatialOctree, Int64}"><code>WhatsThePoint.subdivide!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">subdivide!(octree::SpatialOctree, box_idx::Int) -&gt; SVector{8,Int}</code></pre><p>Subdivide box into 8 children. Returns child indices [1:8].</p><p><strong>Child Ordering (Standard Octree Convention)</strong></p><p>1: (0,0,0) - bottom-left-front   (x-, y-, z-) 2: (1,0,0) - bottom-right-front  (x+, y-, z-) 3: (0,1,0) - top-left-front      (x-, y+, z-) 4: (1,1,0) - top-right-front     (x+, y+, z-) 5: (0,0,1) - bottom-left-back    (x-, y-, z+) 6: (1,0,1) - bottom-right-back   (x+, y-, z+) 7: (0,1,1) - top-left-back       (x-, y+, z+) 8: (1,1,1) - top-right-back      (x+, y+, z+)</p><p><strong>Arguments</strong></p><ul><li><code>box_idx</code>: Index of box to subdivide (must be leaf)</li></ul><p><strong>Returns</strong></p><p>SVector{8,Int} of child indices in standard order</p></div></section></details></article><article><details class="docstring" open="true"><summary id="WhatsThePoint.triangle_box_intersection-Union{Tuple{T}, NTuple{5, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><a class="docstring-binding" href="#WhatsThePoint.triangle_box_intersection-Union{Tuple{T}, NTuple{5, StaticArraysCore.SVector{3, T}}} where T&lt;:Real"><code>WhatsThePoint.triangle_box_intersection</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">triangle_box_intersection(
    v1::SVector{3,T},
    v2::SVector{3,T},
    v3::SVector{3,T},
    box_min::SVector{3,T},
    box_max::SVector{3,T}
) where {T&lt;:Real} -&gt; Bool</code></pre><p>Test if triangle (v1, v2, v3) intersects axis-aligned box.</p><p>Uses the Separating Axis Theorem (SAT) with 13 potential separating axes:</p><ul><li>3 box face normals (x, y, z axes)</li><li>1 triangle normal</li><li>9 edge-edge cross products</li></ul><p>If any axis separates the triangle and box, they don&#39;t intersect.</p><p><strong>Algorithm</strong></p><ol><li>Translate triangle and box so box is centered at origin</li><li>Test each potential separating axis</li><li>Return false if any axis separates, true otherwise</li></ol><p><strong>References</strong></p><ul><li>Akenine-M√∂ller, &quot;Fast 3D Triangle-Box Overlap Testing&quot; (2001)</li><li>Ericson, &quot;Real-Time Collision Detection&quot;, Chapter 5.2.9</li></ul><p><strong>Performance</strong></p><p>Optimized with early-out tests. Average case is much faster than worst case.</p></div></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../octree/">¬´ Octree</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Wednesday 25 February 2026 22:36">Wednesday 25 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
